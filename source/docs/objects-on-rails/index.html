<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Objects on Rails</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2011-11-16 01:13:53 EST"/>
<meta name="author" content="Avdi Grimm"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Objects on Rails</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 About </a>
<ul>
<li><a href="#sec-1-1">1.1 History </a></li>
</ul>
</li>
<li><a href="#sec-2">2 Preface </a></li>
<li><a href="#sec-3">3 Introduction </a>
<ul>
<li><a href="#sec-3-1">3.1 What this is not </a></li>
<li><a href="#sec-3-2">3.2 About the approach </a></li>
<li><a href="#sec-3-3">3.3 A note on scale </a></li>
<li><a href="#sec-3-4">3.4 Why OOP? </a></li>
</ul>
</li>
<li><a href="#sec-4">4 Yet another frickin' blog app </a></li>
<li><a href="#sec-5">5 Adding blog entries </a>
<ul>
<li><a href="#sec-5-1">5.1 Placeholder blog entries </a></li>
<li><a href="#sec-5-2">5.2 Making new entries </a></li>
<li><a href="#sec-5-3">5.3 The <code>Post</code> class </a></li>
<li><a href="#sec-5-4">5.4 Why <code>#publish</code>? </a></li>
<li><a href="#sec-5-5">5.5 Adding entries to the blog </a></li>
</ul>
</li>
<li><a href="#sec-6">6 Submitting posts </a></li>
<li><a href="#sec-7">7 Getting the tests running again </a></li>
<li><a href="#sec-8">8 Adding timestamps </a></li>
<li><a href="#sec-9">9 OMG Dependency Injection! </a></li>
<li><a href="#sec-10">10 Sorting and limiting posts </a></li>
<li><a href="#sec-11">11 Adding validation </a></li>
<li><a href="#sec-12">12 Presenters </a>
<ul>
<li><a href="#sec-12-1">12.1 Presenting the Presenter </a></li>
<li><a href="#sec-12-2">12.2 Refactoring the presenters </a></li>
<li><a href="#sec-12-3">12.3 Do we need helpers? </a></li>
</ul>
</li>
<li><a href="#sec-13">13 Presenters for REST </a></li>
<li><a href="#sec-14">14 Making the data stick around </a>
<ul>
<li><a href="#sec-14-1">14.1 The trouble with ActiveRecord </a></li>
<li><a href="#sec-14-2">14.2 Adding ActiveRecord </a></li>
<li><a href="#sec-14-3">14.3 Why does <code>Blog</code> do the saving? </a></li>
<li><a href="#sec-14-4">14.4 Updating the <code>Blog</code> tests </a></li>
<li><a href="#sec-14-5">14.5 Separating out integration tests </a></li>
<li><a href="#sec-14-6">14.6 Updating the <code>Post</code> tests </a></li>
<li><a href="#sec-14-7">14.7 Using ActivRecord objects as data access objects </a></li>
</ul>
</li>
<li><a href="#sec-15">15 Concealing ActiveRecord behind a <code>FigLeaf</code> </a></li>
<li><a href="#sec-16">16 Adding tags </a></li>
<li><a href="#sec-17">17 An Object Model for Tags </a></li>
<li><a href="#sec-18">18 Attaching the <code>TagList</code> to a <code>Post</code> </a></li>
<li><a href="#sec-19">19 Making <code>Post</code> more tag-aware </a></li>
<li><a href="#sec-20">20 Accepting and displaying tags </a></li>
<li><a href="#sec-21">21 Extracting a Taggable role </a></li>
<li><a href="#sec-22">22 Refactoring to a separate ActiveRecord model </a></li>
<li><a href="#sec-23">23 Data-Context-Interaction </a></li>
<li><a href="#sec-24">24 Conclusion </a>
<ul>
<li><a href="#sec-24-1">24.1 Feelin' the burn </a></li>
<li><a href="#sec-24-2">24.2 Wrap-up </a></li>
</ul>
</li>
<li><a href="#sec-25">25 Further reading </a></li>
<li><a href="#sec-26">26 Photo Credits </a></li>
<li><a href="#sec-27">27 Issues </a>
<ul>
<li><a href="#sec-27-1">27.1 Either resolve or explain mixed "entries"/"posts" terminology </a></li>
<li><a href="#sec-27-2">27.2 Show all requires? </a></li>
<li><a href="#sec-27-3">27.3 Show definition of <code>pubdate</code> accessors </a></li>
<li><a href="#sec-27-4">27.4 Reference Greg Moeck's work </a></li>
<li><a href="#sec-27-5">27.5 Consider Droid Sans for HTML version </a></li>
<li><a href="#sec-27-6">27.6 Talk a little about the project setup </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> About </h2>
<div class="outline-text-2" id="text-1">

<p>  <img src="./images/snail-rail.png" align="center" style="border: 1px solid black" alt="./images/snail-rail.png" />
</p>
<p>
  Objects on Rails
</p>
<p>
  Copyright &copy; 2011 by Avdi Grimm. All rights reserved.
</p>
<p>
  Version 0.0.2
</p>
<p>
  Have comments, suggestions, or corrections; or want to discuss the
  book with other readers? Go to:
  <a href="https://groups.google.com/group/objects-on-rails">https://groups.google.com/group/objects-on-rails</a>
</p>

</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> History </h3>
<div class="outline-text-3" id="text-1-1">



<ul>
<li>2011-11-16 First round of typo fixes after beta release
</li>
</ul>




</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Preface </h2>
<div class="outline-text-2" id="text-2">


<p>
  This was supposed to be a blog post, or at most a series of blog
  posts. Frequently at conferences and users groups I find myself
  discussing the intersection of Ruby on Rails, Object-Oriented
  development, and Test-Driven Development, and I'll mention something
  like "I prefer to develop my business objects first, and add
  ActiveRecord in later". This usually leads to questions about how I
  structure my projects, how I isolate the business logic from
  ActiveRecord for testing, and so on. These discussions usually wind
  up with me saying "I'll write a blog post about it&hellip;".
</p>
<p>
  This is that blog post, or at least it started out that way. I
  quickly realized that the only way to show my approach without a lot
  of hand-waving was to build a project from scratch, showing every
  step. The resulting code and text quickly ballooned, and the result
  is the text you are reading now.
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Introduction </h2>
<div class="outline-text-2" id="text-3">


<p>
Hi there! Welcome to Objects on Rails. This text is a step-by-step
walkthrough following the construction of a simple web application
using Ruby on Rails. It differs from other such walkthroughs in that
it attempts to apply a strongly Object-Oriented philosophy to the
process.
</p>
<p>
"Wait a sec" you may ask. "Isn't Rails already Object-Oriented?" Well,
yes and no. While Rails is written in a thoroughly OO language, and built on
some solid OO patterns, there are aspects of conventional Rails
application development which depart significantly from OO practices.
</p>
<p>
Which is not necessarily a problem in and of itself. Lots of programs
get by just fine with (for instance) a mix of OO and Functional
programming styles. But experience has shown that these same Rails
not-so-OO practices, such as Single Responsibility Principle (SRP)
violations in models, or complex business logic in helpers, are a
common source of development headaches and delays in maturing Rails
applications.
</p>
<p>
In this text, we'll step through building a Rails application using
some techniques I've found efficacious for keeping apps on the
object-oriented rails.
</p>
<p>
We'll also take a look at some more experimental techniques. Full
disclosure: I've used the development of this text as a proving ground
for some approaches I haven't yet applied to production
applications. I don't think anything I'm presenting here is a terrible
idea (or I wouldn't be presenting it); but some of the strategies
haven't been battle-tested over the full development cycle. In
transferring what you learn into your own work, use judgment, confer
with the rest of your team, and don't rewrite your whole app
overnight.
</p>

</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> What this is not </h3>
<div class="outline-text-3" id="text-3-1">


<dl>
<dt>This is not a Rails tutorial</dt><dd>Familiarity with Rails and Ruby is assumed.
</dd>
<dt>This is not a Rails critique</dt><dd>This is not all about how "Rails is
     wrong". Rails is a terrifically powerful framework for quickly
     assembling web applications. I'm interested in how to better use
     the tools Rails provides, not so much in how to subvert or
     replace them.
</dd>
<dt>This is not comprehensive</dt><dd>This is just a catalog of some
     techniques I'm using in late 2011. It doesn't capture every
     possible application of OO patterns or SOLID principles to Rails
     development.
</dd>
<dt>This is not a rule book or a "best-practices" manual</dt><dd>The last
     thing I want anyone to do is follow the approach shown here as a
     book of rules for how to build a Rails application "right". I
     hope that you'll consider the patterns and idioms presented here,
     and select the ones that speak to you and make sense for your
     application.
</dd>
</dl>


</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> About the approach </h3>
<div class="outline-text-3" id="text-3-2">


<p>
   This text takes the form of a walkthrough. We'll build an app
   step-by-step using Test-Driven Design (TDD), at most steps
   presenting test code followed by implementation code.
</p>
<p>
   However, while we will use TDD at the unit test level to drive
   development, there is a major piece missing from our TDD
   stack. Ordinarily, when building a "real" app, I would drive each
   feature from the outside in using acceptance tests, typically
   writtin using Cucumber. However, in the interests of brevity, I
   omit the acceptance testing component in this document.
</p>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> A note on scale </h3>
<div class="outline-text-3" id="text-3-3">


<p>
   The challenge in writing about code patterns is to come up with
   examples that are simple and clear enough that the supporting code
   doesn't get in the way of understanding the specific technique
   being demonstrated&ndash;while still hopefully avoiding examples that
   feel completely contrived. Unfortunately, if you succeed in that,
   you are often confronted with a new problem: the example problems
   you carefully distilled down to their essence now seem so simple,
   so trivial that whatever refactoring or abstraction you're trying
   to illustrate seems superfluous and a waste of effort.
</p>
<p>
   The application I work through in these pages is a deliberately
   simple one, and many of the techniques I demonstrate may seem like
   massive overkill for the task at hand. Please understand, as you
   read through the examples, that these are patterns and idioms
   intended to make the development and evolution of large-scale
   applications more tractable. While they may seem less than
   compelling in the context of a "toy" app, hopefully you can
   visualize how they might be helpful for larger-scale development.
</p>
</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Why OOP? </h3>
<div class="outline-text-3" id="text-3-4">


<p>
Why bother with these techniques? What's wrong with the way we've
always written Rails applications?
</p>
<p>
The biggest reason&mdash;scratch that, the <em>only</em> reason&mdash;is to make our
apps easier to change. The only constant in life is change, and that
goes double for software projects. Markets change, requirements change,
external dependencies change, and platforms change. As <a href="http://avdi.org/devblog/2011/08/22/your-code-is-my-hell/">I've written about at length</a> elsewhere, Rails is reaching a point at the time of
writing where a lot of projects are starting to mature, and a lot of
developers are realizing their projects aren't nearly as easy to
modify as they used to be.
</p>
<p>
It's risky for me to give some specific example, e.g. "by
following these guidelines, you'll be able to easily change to MongoDB
in the future!". Inevitably someone will say "hah, my app will never
need to switch to MongoDB, therefore I don't need these techniques!"
</p>
<p>
Attempts to predict <em>which</em> parts of a codebase will need to change,
and to structure it accordingly, have ended badly more often than
not. Part of the nature of change is that you often don't know
beforehand <em>what</em> is going to need change. In this text I'm not going
to attempt to say "using such and so technique will make such and so
component easier to change". In fact, I would encourage you not to
spend too much time thinking about what is most likely to change. Much
like premature optimization, premature change management usually
misses the mark.
</p>
<p>
Amongst all this uncertainty, there are some basic principles that
have proven, over decades of Object-Oriented software development, to
make software generally more flexible and amenable to
change. Principles such as:
</p>
<ul>
<li>Small objects with a single, well-defined responsibility.
</li>
<li>Small methods that do only one thing.
</li>
<li>Limiting the number of types an object collaborates with.
</li>
<li>Strictly limiting the use of global state and singletons (that
  includes limiting the use of class-level methods).
</li>
<li>Small object interfaces with simple method signatures.
</li>
<li>Preferring composition over inheritance.
</li>
</ul>


<p>
These rules of thumb, practiced habitually, tend to lead to more flexible
codebases which can adapt to <em>any</em> type of change adroitly; whether
the change is a data model which better resembles the problem domain;
a new data storage backend; or a re-structuring of the app into a
half-dozen mini-apps.
</p>
<p>
So the answer to <em>why</em>, in the end, is "because things change". Some
good habits early on in a project can save a lot of headaches down the
road.
</p>
<p>
With that intent in mind, let's jump in!
</p>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Yet another frickin' blog app </h2>
<div class="outline-text-2" id="text-4">


<p>
Let's write a new blog app in Rails, since no one's ever done that before!
</p>
<p>
I guess we should start with the home page. Let's add a route:
</p>



<pre class="src src-ruby">root <span class="org-constant">:to</span> =&gt; <span class="org-string">"blog#index"</span>
</pre>




<p>
Now we'll need a controller for that route to work:
</p>



<pre class="example">$ rails g controller blog index
   identical  app/controllers/blog_controller.rb
       route  get "blog/index"
      invoke  erb
       exist    app/views/blog
   identical    app/views/blog/index.html.erb
      invoke  helper
   identical    app/helpers/blog_helper.rb
</pre>



<p>
Hmm, what should the view look like?
</p>
<p>
Well, we <em>are</em> presenting a blog. So presumably we'll have an object
to represent the blog.
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/index.html.erb </span><span class="org-comment-delimiter">--&gt;</span>

&lt;<span class="org-function-name">h1</span>&gt;&lt;%= @blog.title %&gt;&lt;/<span class="org-function-name">h1</span>&gt;
&lt;<span class="org-function-name">h2</span>&gt;&lt;%= @blog.subtitle %&gt;&lt;/<span class="org-function-name">h2</span>&gt;
</pre>




<p>
OK, now we know we need a blog object in the view. Let's create it in
the controller:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/controllers/blog_controller.rb</span>

<span class="org-keyword">class</span> <span class="org-type">BlogController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-keyword">def</span> <span class="org-function-name">index</span>
    <span class="org-variable-name">@blog</span> = <span class="org-type">Blog</span>.new
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
Looks like we need a <code>Blog</code> class next.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/models/blog.rb</span>

<span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-keyword">def</span> <span class="org-function-name">title</span>
    <span class="org-string">"Watching Paint Dry"</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">subtitle</span>
    <span class="org-string">"The trusted source for drying paint news &amp; opinion"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
At this point we can load the page:
</p>
<p>
<img src="./images/bloog-title-subtitle.png"  alt="./images/bloog-title-subtitle.png" />
</p>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Adding blog entries </h2>
<div class="outline-text-2" id="text-5">


<p>
A blog without entries isn't very useful. Let's add blog posts to the
app. Since we're adding something more complex than just static
strings, we'll TDD it. Just to prove there's nothing up our sleeves,
we'll use minitest:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/blog_spec.rb</span>

require <span class="org-string">'minitest/autorun'</span>
require_relative <span class="org-string">'../../app/models/blog'</span>

describe <span class="org-type">Blog</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">Blog</span>.new
  <span class="org-keyword">end</span>

  it <span class="org-string">"should have no entries"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.entries.must_be_empty
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
Running this spec results in a failure:
</p>



<pre class="example">$ ruby spec/models/blog_spec.rb 
Loaded suite spec/models/blog_spec
Started
E
Finished in 0.001575 seconds.

  1) Error:
test_0001_should_have_no_entries(BlogSpec):
NoMethodError: undefined method `entries' for #&lt;Blog:0x894b044&gt;
    spec/models/blog_spec.rb:10:in `block (2 levels) in &lt;main&gt;'

1 tests, 0 assertions, 0 failures, 1 errors, 0 skips
</pre>



<p>
To make it pass, we add an <code>entries</code> attribute to <code>Blog</code>:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  attr_reader <span class="org-constant">:entries</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>
    <span class="org-variable-name">@entries</span> = []
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
When we run the tests again, they pass:
</p>



<pre class="example">$ ruby spec/models/blog_spec.rb 
Loaded suite spec/models/blog_spec
Started
.
Finished in 0.002619 seconds.

1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
</pre>



<p>
You may have noticed that we're not using any kind of Rails
integration for setting up and running the tests. We're not even
relying on Rails constant autoloading. This is intentional. By writing
ordinary "plain old tests" which don't rely on any special Rails
helpers, we keep the tests isolated and force ourselves to be
deliberate about creating any dependencies between our objects. We
anticipate that this will have a salutory effect on the object design
which emerges from our TDD process.
</p>
<p>
As a welcome side effect, the tests run ridiculously fast.
</p>

</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Placeholder blog entries </h3>
<div class="outline-text-3" id="text-5-1">


<p>
OK, now we have an <code>entries</code> attribute on <code>Blog</code>, but there's nothing
in it. Let's add some temporary example blog posts in the
<code>BlogController</code>.
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">index</span>
  <span class="org-variable-name">@blog</span> = <span class="org-type">Blog</span>.new
  post1 = <span class="org-variable-name">@blog</span>.new_post
  post1.title = <span class="org-string">"Paint just applied"</span>
  post1.body = <span class="org-string">"Paint just applied. It's a lovely orangey-purple!"</span>
  post1.publish
  post2 = <span class="org-variable-name">@blog</span>.new_post(title: <span class="org-string">"Still wet"</span>)
  post2.body = <span class="org-string">"Paint is still quite wet. No bubbling yet!"</span>
  post2.publish
<span class="org-keyword">end</span>
</pre>




<p>
You may have noticed that we're calling a <code>#new_post</code> method which
doesn't exist yet, followed by some other methods on the return value
which also don't exist. Now that we know what code we need, let's make
it exist.
</p>
</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Making new entries </h3>
<div class="outline-text-3" id="text-5-2">


<p>
First, let's specify that <code>#new_post</code> method. Clearly it needs to
return some kind of blog post object which is associated with the Blog
object. However, we want to keep our tests isolated, and we only want
to test one model at a time. So we'll make the process by which new
posts are created easy to swap out:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  attr_writer <span class="org-constant">:post_maker</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-keyword">private</span>

  <span class="org-keyword">def</span> <span class="org-function-name">post_maker</span>
    <span class="org-variable-name">@post_maker</span> ||= <span class="org-type">Post</span>.public_method(<span class="org-constant">:new</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
During normal operation, <code>Blog</code> will use the (not yet written)
<code>Post.new</code> method to generate post objects. But we can substitute any
<code>call</code>-able object when testing the class.
</p>
<p>
Now we'll make some assertions about how <code>Blog#new_post</code> should behave:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/blog_spec.rb</span>

describe <span class="org-type">Blog</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  describe <span class="org-string">"#new_post"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@new_post</span> = <span class="org-type">OpenStruct</span>.new
      <span class="org-variable-name">@it</span>.post_maker = -&gt;{ <span class="org-variable-name">@new_post</span> }
    <span class="org-keyword">end</span>

    it <span class="org-string">"should return a new post"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.new_post.must_equal <span class="org-variable-name">@new_post</span>
    <span class="org-keyword">end</span>

    it <span class="org-string">"should set the post's blog reference to itself"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.new_post.blog.must_equal(<span class="org-variable-name">@it</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
Here, we substitute a lambda which simply returns an <code>OpenStruct</code> for
the <code>#post_maker</code>.
</p>
<p>
Making these pass is straightforward:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-keyword">def</span> <span class="org-function-name">new_post</span>
    post_maker.call.tap <span class="org-keyword">do</span> |p|
      p.blog = <span class="org-variable-name">self</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




</div>

</div>

<div id="outline-container-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> The <code>Post</code> class </h3>
<div class="outline-text-3" id="text-5-3">


<p>
It's pretty obvious that our next step needs to be creating a <code>Post</code>
class. Let's specify its behavior.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/post_spec.rb</span>

require <span class="org-string">'minitest/autorun'</span>
require_relative <span class="org-string">'../../app/models/post'</span>

describe <span class="org-type">Post</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">Post</span>.new
  <span class="org-keyword">end</span>

  it <span class="org-string">"should start with blank attributes"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.title.must_be_nil
    <span class="org-variable-name">@it</span>.body.must_be_nil
  <span class="org-keyword">end</span>

  it <span class="org-string">"should support reading and writing a title"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.title = <span class="org-string">"foo"</span>
    <span class="org-variable-name">@it</span>.title.must_equal <span class="org-string">"foo"</span>
  <span class="org-keyword">end</span>

  it <span class="org-string">"should support reading and writing a post body"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.body = <span class="org-string">"foo"</span>
    <span class="org-variable-name">@it</span>.body.must_equal <span class="org-string">"foo"</span>
  <span class="org-keyword">end</span>

  it <span class="org-string">"should support reading and writing a blog reference"</span> <span class="org-keyword">do</span>
    blog = <span class="org-type">Object</span>.new
    <span class="org-variable-name">@it</span>.blog = blog
    <span class="org-variable-name">@it</span>.blog.must_equal blog
  <span class="org-keyword">end</span>

  describe <span class="org-string">"#publish"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@blog</span> = <span class="org-type">MiniTest</span>::<span class="org-type">Mock</span>.new
      <span class="org-variable-name">@it</span>.blog = <span class="org-variable-name">@blog</span>
    <span class="org-keyword">end</span>

    after <span class="org-keyword">do</span>
      <span class="org-variable-name">@blog</span>.verify
    <span class="org-keyword">end</span>

    it <span class="org-string">"should add the post to the blog"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@blog</span>.expect <span class="org-constant">:add_entry</span>, <span class="org-variable-name">nil</span>, [<span class="org-variable-name">@it</span>]
      <span class="org-variable-name">@it</span>.publish
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
Next we satisfy the specification:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/models/post.rb</span>

<span class="org-keyword">class</span> <span class="org-type">Post</span>
  attr_accessor <span class="org-constant">:blog</span>, <span class="org-constant">:title</span>, <span class="org-constant">:body</span>

  <span class="org-keyword">def</span> <span class="org-function-name">publish</span>
    blog.add_entry(<span class="org-variable-name">self</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




</div>

</div>

<div id="outline-container-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Why <code>#publish</code>? </h3>
<div class="outline-text-3" id="text-5-4">


<p>
If you've written a few Rails apps you may be wondering why we're
calling the method which makes a new blog entry <code>#publish</code> instead of
<code>#save</code>.
</p>
<p>
One of the central elements of object-oriented design is capturing the
<em>language of the domain</em> in our models. Think for a minute about the
language of blogging. No one ever says "I <em>saved</em> a blog post the
other day". They say "I <em>published</em> a blog post" or maybe "I <em>posted</em>
a blog entry". By calling the method <code>#publish</code>, we are continuing to
build a system which echoes our mental model of the domain.
</p>
<p>
Consider how we might extend this program in the future. We might add
scheduled posts, which appear some period of days later than they are
first saved. We might also add a draft state for posts, where they are
saved but they are only visible to the blog owner.
</p>
<p>
Our choice of the verb <code>#publish</code> fits right into this extended
workflow:
</p>



<pre class="src src-ruby">post.save_draft
<span class="org-comment-delimiter"># </span><span class="org-comment">followed by ...</span>
post.schedule
<span class="org-comment-delimiter"># </span><span class="org-comment">or...</span>
post.publish
</pre>




<p>
This is not a coincidence. Choosing appropriate domain language for
program elements often means we don't need to rename as many things as
we add more features down the road.
</p>
</div>

</div>

<div id="outline-container-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Adding entries to the blog </h3>
<div class="outline-text-3" id="text-5-5">


<p>
Driving out <code>Post</code> has revealed that we need one more method on
<code>Blog</code>, one which will actually add the post to the blog. We'll
quickly spec it out and add it.
</p>



<pre class="src src-ruby">describe <span class="org-type">Blog</span> <span class="org-keyword">do</span>
  describe <span class="org-string">"#add_entry"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"should add the entry to the blog"</span> <span class="org-keyword">do</span>
      entry = <span class="org-type">Object</span>.new
      <span class="org-variable-name">@it</span>.add_entry(entry)
      <span class="org-variable-name">@it</span>.entries.must_include(entry)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>





<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">add_entry</span>(entry)
    entries &lt;&lt; entry
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
Looking back at our demo code in the <code>BlogController</code>, we remember
that in making a second post, we changed things up a little and passed
in the title as an argument:
</p>



<pre class="src src-ruby">post2 = <span class="org-variable-name">@blog</span>.new_post(title: <span class="org-string">"Still wet"</span>)
</pre>




<p>
Let's modify <code>Blog#new_post</code> to support this syntax. First, the spec:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
it <span class="org-string">"should accept an attribute hash on behalf of the post maker"</span> <span class="org-keyword">do</span>
  post_maker = <span class="org-type">MiniTest</span>::<span class="org-type">Mock</span>.new
  post_maker.expect(<span class="org-constant">:call</span>, <span class="org-variable-name">@new_post</span>, [{<span class="org-constant">:x</span> =&gt; 42, <span class="org-constant">:y</span> =&gt; <span class="org-string">'z'</span>}])
  <span class="org-variable-name">@it</span>.post_maker = post_maker
  <span class="org-variable-name">@it</span>.new_post(<span class="org-constant">:x</span> =&gt; 42, <span class="org-constant">:y</span> =&gt; <span class="org-string">'z'</span>)
  post_maker.verify
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
And then the implementation:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">new_post</span>(*args)
  post_maker.call(*args).tap <span class="org-keyword">do</span> |p|
    p.blog = <span class="org-variable-name">self</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Now we're passing the arguments along, but we still need to implement
keyword arguments on the <code>Post</code> initializer.
</p>



<pre class="src src-ruby">describe <span class="org-type">Post</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  it <span class="org-string">"should support setting attributes in the initializer"</span> <span class="org-keyword">do</span>
    it = <span class="org-type">Post</span>.new(<span class="org-constant">:title</span> =&gt; <span class="org-string">"mytitle"</span>, <span class="org-constant">:body</span> =&gt; <span class="org-string">"mybody"</span>)
    it.title.must_equal <span class="org-string">"mytitle"</span>
    it.body.must_equal <span class="org-string">"mybody"</span>
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>





<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(attrs={})
    attrs.each <span class="org-keyword">do</span> |k,v| send(<span class="org-string">"</span><span class="org-variable-name">#{k}</span><span class="org-string">="</span>,v) <span class="org-keyword">end</span> 
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
Now we just need to update the views to show our posts.
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/index.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">h1</span>&gt;&lt;%= @blog.title %&gt;&lt;/<span class="org-function-name">h1</span>&gt;
&lt;<span class="org-function-name">h2</span>&gt;&lt;%= @blog.subtitle %&gt;&lt;/<span class="org-function-name">h2</span>&gt;
&lt;%= render partial: <span class="org-string">"entry"</span>, collection: @blog.entries %&gt;
</pre>





<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/_entry.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= entry.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;<span class="org-function-name">p</span>&gt;&lt;%= entry.body %&gt;&lt;/<span class="org-function-name">p</span>&gt;
&lt;/<span class="org-function-name">article</span>&gt;
</pre>




<p>
Reloading the page, we can see our demo entries.
</p>

<div class="figure">
<p><img src="./images/showing-entries.png"  alt="./images/showing-entries.png" /></p>
<p>Showing entries</p>
</div>

</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Submitting posts </h2>
<div class="outline-text-2" id="text-6">


<p>
This is progress, but a blog with static entries doesn't do us a lot
of good. We need to be able to submit new entries.
</p>
<p>
First we'll add a "New post" link.
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/layouts/application.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">div</span> <span class="org-variable-name">class</span>=<span class="org-string">"sidebar two columns"</span>&gt;
  &lt;<span class="org-function-name">nav</span>&gt;
    &lt;<span class="org-function-name">ul</span>&gt;
      &lt;<span class="org-function-name">li</span>&gt;&lt;%= link_to <span class="org-string">"New post..."</span>, new_post_path %&gt;&lt;/<span class="org-function-name">li</span>&gt;
    &lt;/<span class="org-function-name">ul</span>&gt;
  &lt;/<span class="org-function-name">nav</span>&gt;
&lt;/<span class="org-function-name">div</span>&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
</pre>




<p>
For that <code>new_post_path</code> call to work we need a route:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">config/routes.rb</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
resources <span class="org-constant">:posts</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
And for the route to work we need a controller:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/controllers/posts_controller.rb</span>

<span class="org-keyword">class</span> <span class="org-type">PostsController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-keyword">def</span> <span class="org-function-name">new</span>
    <span class="org-variable-name">@post</span> = <span class="org-variable-name">@blog</span>.new_post
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
Looks like we need the <code>@blog</code> object in the <code>PostsController</code> as well
as the <code>BlogController</code>. Time to factor the code that sets it out into the
<code>ApplicationController</code>:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/controllers/application_controller.rb</span>

<span class="org-keyword">class</span> <span class="org-type">ApplicationController</span> &lt; <span class="org-type">ActionController</span>::<span class="org-type">Base</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  before_filter <span class="org-constant">:init_blog</span>

  <span class="org-keyword">private</span>

  <span class="org-keyword">def</span> <span class="org-function-name">init_blog</span>
    <span class="org-variable-name">@blog</span> = <span class="org-type">Blog</span>.new
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
That's enough to make the link render but we need somewhere for it to
go. We'll create a quick "new post" form:
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/posts/new.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">h1</span>&gt;<span class="org-underline"><span class="org-bold">New Post</span></span>&lt;/<span class="org-function-name">h1</span>&gt;
&lt;%= form_for @post do |f| %&gt;
  &lt;%= f.text_field :title %&gt;
  &lt;%= f.text_area :body %&gt;
  &lt;%= f.submit %&gt;
&lt;% end %&gt;
</pre>




<p>
We're almost there, but in order to construct paths and render forms,
Rails has certain expectations about the protocols that a model object
will respond to&mdash;protocols that our basic <code>Post</code> class doesn't know
about. The easiest way to make it compliant is to add a couple of
modules from <code>ActiveModel</code>. We also need to implement one method
ourselves: <code>#persisted?</code>. For now, it's sufficient to just return
<code>false</code>.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  extend <span class="org-type">ActiveModel</span>::<span class="org-type">Naming</span>
  include <span class="org-type">ActiveModel</span>::<span class="org-type">Conversion</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-keyword">def</span> <span class="org-function-name">persisted?</span>
    <span class="org-variable-name">false</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
With that change, we can click on our "New post&hellip;" link and see a new
post form.
</p>

<div class="figure">
<p><img src="./images/new-post.png"  alt="./images/new-post.png" /></p>
<p>New post form</p>
</div>

<p>
So far so good. Now let's make submitting the form work. We need to
add a <code>PostsController#create</code> action.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">PostsController</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">create</span>
    <span class="org-variable-name">@post</span> = <span class="org-variable-name">@blog</span>.new_post(params[<span class="org-constant">:post</span>])
    <span class="org-variable-name">@post</span>.publish
    redirect_to root_path, <span class="org-constant">:notice</span> =&gt; <span class="org-string">"Post added!"</span>
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
We can get rid of the demo posts in <code>BlogController</code> now.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">BlogController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-keyword">def</span> <span class="org-function-name">index</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
There's just one little problem remaining: a new blog object&mdash;and
hence a new, blank list of posts!&mdash;is created with every request. We
need to make a single blog object last across requests.
</p>
<p>
Our app only supports a single blog at the moment, so we'll just
store an instance to an app-wide <code>Blog</code> object using an initializer.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">config/initializers/blog.rb</span>
<span class="org-type">THE_BLOG</span> = <span class="org-type">Blog</span>.new
</pre>




<p>
Now we change the before filter which sets the <code>@blog</code> variable to use
that constant:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">ApplicationController</span> &lt; <span class="org-type">ActionController</span>::<span class="org-type">Base</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">init_blog</span>
    <span class="org-variable-name">@blog</span> = <span class="org-type">THE_BLOG</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
And now we can submit new posts!
</p>
<p>
<img src="./images/post-added.png"  alt="./images/post-added.png" />
</p>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Getting the tests running again </h2>
<div class="outline-text-2" id="text-7">


<p>
Unfortunately, our changes to the <code>Posts</code> model have broken our tests.
</p>



<pre class="src src-example">$ ruby spec/models/post_spec.rb 
app/models/post.rb:2:in `&lt;class:Post&gt;': uninitialized constant Post::ActiveModel (NameError)
        from /home/avdi/Dropbox/books/objects-on-the-web/bloog/app/models/post.rb:1:in `&lt;top (required)&gt;'
        from spec/models/post_spec.rb:2:in `require_relative'
        from spec/models/post_spec.rb:2:in `&lt;main&gt;'
</pre>




<p>
Our nicely isolated tests don't know where to find ActiveModel.
</p>
<p>
We could fix this by requiring ActiveModel somewhere in the test
setup. But we don't actually <em>need</em> ActiveModel for the tests to
pass. And we really like how fast the tests run with so few
dependencies. Is there some way we can continue to keep our models as
lightweight as possible while testing their behavior, and only use
dependencies like ActiveModel when running as part of an application?
Let's find out.
</p>
<p>
Our first crack at this problem might be to simply define empty
versions of the needed modules in the test file, before requiring the
<code>post.rb</code> file.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/post_spec.rb</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">module</span> <span class="org-type">ActiveModel</span>
  <span class="org-keyword">module</span> <span class="org-type">Naming</span>; <span class="org-keyword">end</span>
  <span class="org-keyword">module</span> <span class="org-type">Conversion</span>; <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

require_relative <span class="org-string">'../../app/models/post'</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
This gets the test passing again. But this approach is
problematic. Let's say we had these tests running as part of a Rake
task which also included full-stack tests. As a result, the task
loaded the full Rails environment. Depending on load order, this file
with its empty definitions of <code>ActiveModel::Naming</code> and
<code>ActiveModel::Conversion</code> might cause ActiveSupport to think that
those modules had already been loaded&mdash;and therefore never load the
<em>real</em> versions. This is definitely not what we want.
</p>
<p>
What we really need is a way to conditionally create empty or "stub"
modules only if a) they are not already defined; and b) they are not
auto-loadable. Here's a method which does just that.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/spec_helper_lite.rb</span>
<span class="org-keyword">def</span> <span class="org-function-name">stub_module</span>(full_name)
  full_name.to_s.split(<span class="org-string">/::/</span>).inject(<span class="org-type">Object</span>) <span class="org-keyword">do</span> |context, name|
    <span class="org-keyword">begin</span>
      context.const_get(name)
    <span class="org-keyword">rescue</span> <span class="org-type">NameError</span>
      context.const_set(name, <span class="org-type">Module</span>.new)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
This method uses <code>#const_get</code> to attempt to reference the given
module. If the module is defined, or if calling <code>#const_get</code> causes it
to be auto-loaded, the method does nothing more. But if <code>#const_get</code>
fails to turn up the module, it defines an anonymous empty module to
act as a placeholder.
</p>
<p>
Here it is being used to stub out modules in our <code>Post</code> spec:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
require_relative <span class="org-string">'../spec_helper_lite'</span>

stub_module <span class="org-string">'ActiveModel::Conversion'</span>
stub_module <span class="org-string">'ActiveModel::Naming'</span>

require_relative <span class="org-string">'../../app/models/post'</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
The tests are once again passing:
</p>



<pre class="example">$ ruby spec/models/post_spec.rb                            
Loaded suite spec/models/post_spec
Started
......
Finished in 0.000530 seconds.

6 tests, 7 assertions, 0 failures, 0 errors, 0 skips
</pre>



</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Adding timestamps </h2>
<div class="outline-text-2" id="text-8">


<p>
Two features that are pretty much required for a blog are 1)
time-stamped posts; and 2) listing posts in reverse-chronological
order. So far our blog supports neither of these. Time to fix that.
</p>
<p>
Once again, we'll take an outside-in approach and first find a place
in the views to display the (as-yet nonexistent) timestamp.
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/_entry.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">p</span>&gt;&lt;<span class="org-function-name">time</span> <span class="org-variable-name">pubdate</span>=<span class="org-string">"pubdate"</span>&gt;&lt;%= entry.pubdate %&gt;&lt;/<span class="org-function-name">time</span>&gt;&lt;/<span class="org-function-name">p</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= entry.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;<span class="org-function-name">p</span>&gt;&lt;%= entry.body %&gt;&lt;/<span class="org-function-name">p</span>&gt;
&lt;/<span class="org-function-name">article</span>&gt;
</pre>




<p>
An entry's publishing timestamp should start out blank and then be
filled in once it is published. Let's spec that out.
</p>



<pre class="src src-ruby"><span class="linenr"> 1:  </span><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="linenr"> 2:  </span>describe <span class="org-string">"#pubdate"</span> <span class="org-keyword">do</span>
<span class="linenr"> 3:  </span>  describe <span class="org-string">"before publishing"</span> <span class="org-keyword">do</span>
<span class="linenr"> 4:  </span>    it <span class="org-string">"should be blank"</span> <span class="org-keyword">do</span>
<span class="linenr"> 5:  </span>      <span class="org-variable-name">@it</span>.pubdate.must_be_nil
<span class="linenr"> 6:  </span>    <span class="org-keyword">end</span>
<span class="linenr"> 7:  </span>  <span class="org-keyword">end</span>
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>  describe <span class="org-string">"after publishing"</span> <span class="org-keyword">do</span>
<span class="linenr">10:  </span>    before <span class="org-keyword">do</span>
<span class="linenr">11:  </span>      <span class="org-variable-name">@it</span>.blog = stub! <span class="org-comment-delimiter"># </span><span class="org-comment">(ref:stub)</span>
<span class="linenr">12:  </span>      <span class="org-variable-name">@it</span>.publish
<span class="linenr">13:  </span>    <span class="org-keyword">end</span>
<span class="linenr">14:  </span>    it <span class="org-string">"should be a datetime"</span> <span class="org-keyword">do</span>
<span class="linenr">15:  </span>      <span class="org-variable-name">@it</span>.pubdate.class.must_equal(<span class="org-type">DateTime</span>)
<span class="linenr">16:  </span>    <span class="org-keyword">end</span>
<span class="linenr">17:  </span>  <span class="org-keyword">end</span>
<span class="linenr">18:  </span><span class="org-keyword">end</span>
<span class="linenr">19:  </span><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Note the use of <code>stub!</code> at line <a href="#coderef-stub" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-stub');" onmouseout="CodeHighlightOff(this, 'coderef-stub');">nil</a>. MiniTest's built-in mocking
was becoming insufficient for our needs, so we've supplemented it with
<a href="https://github.com/btakita/rr">rr</a>, a succinct but powerful test double library. Here's the setup for that:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/spec_helper_lite.rb</span>
require <span class="org-string">'rr'</span>

<span class="org-keyword">class</span> <span class="org-type">MiniTest</span>::<span class="org-type">Unit</span>::<span class="org-type">TestCase</span>
  include <span class="org-type">RR</span>::<span class="org-type">Adapters</span>::<span class="org-type">MiniTest</span>
<span class="org-keyword">end</span>
</pre>




<p>
The timestamp isn't much help if it doesn't use the current
time. Let's add a spec asserting that it does.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#pubdate"</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  describe <span class="org-string">"after publishing"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@clock</span> = stub!
      <span class="org-variable-name">@now</span> = <span class="org-type">DateTime</span>.parse(<span class="org-string">"2011-09-11T02:56"</span>)
      stub(<span class="org-variable-name">@clock</span>).now(){<span class="org-variable-name">@now</span>}
      <span class="org-variable-name">@it</span>.blog = stub!
      <span class="org-variable-name">@it</span>.publish(<span class="org-variable-name">@clock</span>)
    <span class="org-keyword">end</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

    it <span class="org-string">"should be the current time"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.pubdate.must_equal(<span class="org-variable-name">@now</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
That's a lot of test setup; any more and we'd want to find a way to
refactor the tests.
</p>
<p>
Now, besides for creating a stubbed <code>blog</code> instance, we're also
creating a <code>@clock</code> stub. We create a fixed <code>@now</code> time for the clock
to respond with when <code>#now</code> is called on it. Then we pass the clock
into the <code>Post#publish</code> method and assert that it uses the <code>@now</code> time
to set its <code>#pubdate</code> attribute.
</p>
<p>
Wait a second&hellip; does this mean the app will always have to pass a
clock object in to <code>Post#publish</code> now? Won't this break our other
tests where we pass nothing to <code>#publish</code>?
</p>
<p>
Sensible defaults to the rescue! Let's update the
<code>Post#publish</code> method to make this test pass:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">publish</span>(clock=<span class="org-type">DateTime</span>)
  <span class="org-variable-name">self</span>.pubdate = clock.now
  blog.add_entry(<span class="org-variable-name">self</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
We add a <code>clock</code> parameter, and make it default to <code>DateTime</code>. That
way in the absence of any parameter, the method will just take its
timestamp from the system clock via <code>DateTime</code>.
</p>
<p>
Why make it possible to pass the clock in? We might turn the question
around: since up until in our unit tests now we've been very careful
to isolate our Code Under Test (CUT) from any external dependencies,
why make an exception for the system clock? By making it possible to
pass a clock object in, we make it very easy to test the behavior of
<code>#publish</code> deterministically, without resorting to heavy-handed
clock-overriding libraries such as <a href="https://github.com/jtrupiano/timecop">Timecop</a>.
</p>
<p>
But there are other advantages to passing the clock in, which we'll
discuss in the next section.
</p>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> OMG Dependency Injection! </h2>
<div class="outline-text-2" id="text-9">


<p>
In constructing carefully isolated tests, we have now used dependency
injection twice. First, we used <em>setter injection</em> to strategize how
<code>Blog</code> objects create new entries:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  attr_writer <span class="org-constant">:post_maker</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-keyword">private</span>

  <span class="org-keyword">def</span> <span class="org-function-name">post_maker</span>
    <span class="org-variable-name">@post_maker</span> ||= <span class="org-type">Post</span>.public_method(<span class="org-constant">:new</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
And then moments ago we used <em>parameter injection</em> to pass in a clock
object to <code>Post#publish</code>:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">publish</span>(clock=<span class="org-type">DateTime</span>)
  <span class="org-variable-name">self</span>.pubdate = clock.now
  blog.add_entry(<span class="org-variable-name">self</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
There is a lot of bad press around the <a href="http://martinfowler.com/articles/injection.html">Dependency Injection pattern</a>
these days. Most of it probably stems from the experiences people have
had with heavyweight DI frameworks in Java and C#. As you can see,
though, at its core Dependency Injection is just about making it
possible to pass an object's collaborators in from the outside. As
we've just seen, Ruby makes it very easy to make dependencies
injectable while still having sensible built-in defaults for those
dependencies.
</p>
<p>
Is all this care taken to make dependencies injectable solely in order
to satisfy our need for isolated tests? Well, certainly that's what
drives us to provide for DI in the first place. But what's interesting
about this discipline of strict isolation is the type of object design
it pushes us towards.
</p>
<p>
Let's say we wanted to add the ability to post-date or pre-date some
posts. Currently, <code>Post</code> sets its <code>pubdate</code> at publish time, so we
can't just set the date when we create the post. Of course, we could
add some new behavior to <code>Post</code> to implement custom <code>pubdate</code> setting;
but because we've made the clock injectable, we can implement custom
publish dates without making any changes at all to <code>Post</code>:
</p>



<pre class="src src-ruby">fixed_clock = <span class="org-type">OpenStruct</span>.new(<span class="org-constant">:now</span> =&gt; <span class="org-type">DateTime</span>.parse(params[<span class="org-constant">:pubdate</span>]))
<span class="org-variable-name">@post</span>.publish(fixed_clock)
</pre>




<p>
Here, we've just used <code>OpenStruct</code> to create a quick ad-hoc object
which responds to the <code>#now</code> method with a fixed date.
</p>
<p>
We could get as fancy as we wanted with custom clocks. We could
implement a delay so that posts have a review period before going
live:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">DelayClock</span>
  <span class="org-keyword">def</span> <span class="org-function-name">now</span>
    <span class="org-type">DateTime</span>.now + 24.hours
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-variable-name">@post</span>.publish(<span class="org-type">DelayClock</span>.new)
</pre>




<p>
All without making any changes to the <code>Post</code> class.
</p>
<p>
According to the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a> (SRP), a class should
have one, and only one, reason to change. In a system that respects
SRP, a single change in functionality ought to mean changing one, and
only one, class.
</p>
<p>
Consider that if we had not made the clock an injectable dependency,
implementing post-dating and pre-dating would have meant changing the
code in (at least) two places: once in the controller, and once in the
<code>Post</code> model. By contrast, in our current design we are able to
implement the feature by changing the code in only one place.
</p>
<p>
By letting our discipline of test isolation drive our design, we
arrived at a system that respects SRP without even really thinking
about it.
</p>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Sorting and limiting posts </h2>
<div class="outline-text-2" id="text-10">


<p>
OK, now we have timestamps on the posts. On a proper blog, posts are
listed in reverse-cronological order, with the most recent post at the
top. Let's implement sorting by timestamp, and while we're at it,
let's limit the display to the ten most recent posts.
</p>
<p>
Spec:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/blog_spec.rb</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#entries"</span> <span class="org-keyword">do</span>
  <span class="org-keyword">def</span> <span class="org-function-name">stub_entry_with_date</span>(date)
    <span class="org-type">OpenStruct</span>.new(<span class="org-constant">:pubdate</span> =&gt; <span class="org-type">DateTime</span>.parse(date))
  <span class="org-keyword">end</span>

  it <span class="org-string">"should be sorted in reverse-chronological order"</span> <span class="org-keyword">do</span>
    oldest = stub_entry_with_date(<span class="org-string">"2011-09-09"</span>)
    newest = stub_entry_with_date(<span class="org-string">"2011-09-11"</span>)
    middle = stub_entry_with_date(<span class="org-string">"2011-09-10"</span>)

    <span class="org-variable-name">@it</span>.add_entry(oldest)
    <span class="org-variable-name">@it</span>.add_entry(newest)
    <span class="org-variable-name">@it</span>.add_entry(middle)
    <span class="org-variable-name">@it</span>.entries.must_equal([newest, middle, oldest])
  <span class="org-keyword">end</span>

  it <span class="org-string">"should be limited to 10 items"</span> <span class="org-keyword">do</span>
    10.times <span class="org-keyword">do</span> |i|
      <span class="org-variable-name">@it</span>.add_entry(stub_entry_with_date(<span class="org-string">"2011-09-</span><span class="org-variable-name">#{i+1}</span><span class="org-string">"</span>))
    <span class="org-keyword">end</span>
    oldest = stub_entry_with_date(<span class="org-string">"2011-08-30"</span>)
    <span class="org-variable-name">@it</span>.add_entry(oldest)
    <span class="org-variable-name">@it</span>.entries.size.must_equal(10)
    <span class="org-variable-name">@it</span>.entries.wont_include(oldest)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Implementation:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/models/blog.rb</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">entries</span>
  <span class="org-variable-name">@entries</span>.sort_by{|e| e.pubdate}.reverse.take(10)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
We also have to change the <code>#add_entry</code> method to reference the
<code>@entries</code> collection directly, now that <code>#entries</code> returns a modified
copy:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">add_entry</span>(entry)
  <span class="org-variable-name">@entries</span> &lt;&lt; entry
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
With that, our blog is starting to behave more like the real thing:
</p>
<p>
<img src="./images/sorted-entries.png"  alt="./images/sorted-entries.png" />
</p>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Adding validation </h2>
<div class="outline-text-2" id="text-11">


<p>
Blog posts, at the very least, should have a title. Let's add a
validation to enforce this constraint.
</p>
<p>
Here's the specification:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
it <span class="org-string">"should not be valid with a blank title"</span> <span class="org-keyword">do</span>
  [<span class="org-variable-name">nil</span>, <span class="org-string">""</span>, <span class="org-string">" "</span>].each <span class="org-keyword">do</span> |bad_title|
    <span class="org-variable-name">@it</span>.title = bad_title
    refute <span class="org-variable-name">@it</span>.valid?
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

it <span class="org-string">"should be valid with a non-blank title"</span> <span class="org-keyword">do</span>
  <span class="org-variable-name">@it</span>.title = <span class="org-string">"x"</span>
  assert <span class="org-variable-name">@it</span>.valid?
<span class="org-keyword">end</span> 
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
We could manually implement a <code>#valid?</code> method here. But we know that
Rails needs more than just a <code>#valid?</code> method in order to present
validation failures in a user-friendly way. And besides, why write
that method when it's a one-liner using ActiveModel?
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  include <span class="org-type">ActiveModel</span>::<span class="org-type">Validations</span>

  validates <span class="org-constant">:title</span>, <span class="org-constant">:presence</span> =&gt; <span class="org-variable-name">true</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
Now that we're using ActiveModel to satisfy our own expectations as
well as Rails' expectations, we can no longer stub out the ActiveModel
modules when running in isolation. We must use the real thing.
</p>
<p>
These lines will have to go:
</p>



<pre class="src src-ruby">stub_module <span class="org-string">'ActiveModel::Conversion'</span>
stub_module <span class="org-string">'ActiveModel::Naming'</span>
</pre>




<p>
And we have to add a requirement for ActiveModel to the model file:
</p>



<pre class="src src-ruby">require <span class="org-string">'active_model'</span>
</pre>




<p>
When running in the full app, this won't be necessary. But we need it
in order to continue running our tests outside of the Rails
environment. By explicitly requiring ActiveModel only in files which
need it, we don't saddle unrelated tests with the extra load time.
</p>
<p>
While we're adding validation to the <code>Post</code> class, let's also modify
the contract of <code>#publish</code> to only add posts to <code>Blog</code> when the post
is valid, and to return <code>false</code> when validation fails.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#publish"</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  describe <span class="org-string">"given an invalid post"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span> <span class="org-variable-name">@it</span>.title = <span class="org-variable-name">nil</span> <span class="org-keyword">end</span>

    it <span class="org-string">"should not add the post to the blog"</span> <span class="org-keyword">do</span>
      dont_allow(<span class="org-variable-name">@blog</span>).add_entry
      <span class="org-variable-name">@it</span>.publish
    <span class="org-keyword">end</span>

    it <span class="org-string">"should return false"</span> <span class="org-keyword">do</span>
      refute(<span class="org-variable-name">@it</span>.publish)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>







<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">publish</span>(clock=<span class="org-type">DateTime</span>)
  <span class="org-keyword">return</span> <span class="org-variable-name">false</span> <span class="org-keyword">unless</span> valid?
  <span class="org-variable-name">self</span>.pubdate = clock.now
  <span class="org-variable-name">@blog</span>.add_entry(<span class="org-variable-name">self</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
With these changes in place, we can update the <code>PostsController</code> to
handle validation failures:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">create</span>
  <span class="org-variable-name">@post</span> = <span class="org-variable-name">@blog</span>.new_post(params[<span class="org-constant">:post</span>])
  <span class="org-keyword">if</span> <span class="org-variable-name">@post</span>.publish
    redirect_to root_path, notice: <span class="org-string">"Post added!"</span>
  <span class="org-keyword">else</span>
    render <span class="org-string">"new"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
With that change and some tweaks to the view (not shown), we now get
an error message when we try to submit a blog post with no title.
</p>

<div class="figure">
<p><img src="./images/validation-error.png"  alt="./images/validation-error.png" /></p>
<p>Validation error message</p>
</div>

</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> Presenters </h2>
<div class="outline-text-2" id="text-12">


<p>
No blog is complete without the ability to post funny cat
pictures. We'd like to add the ability to attach a picture URL to
posts. In addition, we want to present posts differently if they have
a picture URL. The "body" text will become the picture caption.
</p>
<p>
As before, we'll start at the view level and work inward. We'll add a
picture URL field to the new post form:
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/posts/new.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;%= form_for @post do |f| %&gt;
  # ...
  &lt;%= label :image_url, <span class="org-string">"Picture URL:"</span> %&gt;
  &lt;%= f.text_field :image_url %&gt;
  # ...
&lt;% end %&gt;
</pre>




<p>
And we'll create partials for both displaying text-only entries and
for displaying picture entries. Here's the one for picture entries:
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/posts/_picture_body.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">figure</span>&gt;
  &lt;<span class="org-function-name">img</span> <span class="org-variable-name">src</span>=<span class="org-string">"&lt;%= post.image_url %&gt;"</span>/&gt;
  &lt;<span class="org-function-name">figcaption</span>&gt;&lt;%= post.body %&gt;&lt;/<span class="org-function-name">figcaption</span>&gt;
&lt;<span class="org-function-name">figure</span>/&gt;
</pre>




<p>
We're using the HTML5 <code>&lt;figure&gt;</code> and <code>&lt;figcaption&gt;</code> tags to mark
up a picture semantically.
</p>
<p>
We also go ahead and add an <code>image_url</code> attribute to the <code>Post</code> model.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
attr_accessor <span class="org-constant">:blog</span>, <span class="org-constant">:title</span>, <span class="org-constant">:body</span>, <span class="org-constant">:image_url</span>, <span class="org-constant">:pubdate</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Now the question is how to ensure that the correct partial is rendered
based one what kind of post it is. Initially, we might think to do
something like this:
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/_entry.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;% if entry.image_url.present? %&gt;
  &lt;%= render <span class="org-string">"/posts/picture_body"</span>, post: entry %&gt;
&lt;% else %&gt;
  &lt;%= render <span class="org-string">"posts/text_body"</span>, post: entry %&gt;
&lt;% end %&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
</pre>




<p>
But this raises some warning flags. Logic in views is almost
always bad news, even logic as simple as this. Speaking from my own
experience, a lot of the technical debt I've seen in Rails projects
has been in convoluted view code. If possible, it would be nice to
avoid going down that road so early in the project.
</p>
<p>
And anyway, from an Object-Oriented Design perspective this just feels
<em>wrong</em>. Remember those beginning OO examples, where you send a "draw"
message to a "shape" object, and if it's a Circle it will draw a
circle, and if it's a square it will draw a square? What's the point
of using an OO language if we can't use polymorphism, and instead fall
back on conditionals everywhere?
</p>
<p>
Conceptually what we have here are two post types: a "picture post",
and a "text post". The core of OO philosophy is representing discrete
concepts as objects. So let's take these two concepts and represent
them as objects.
</p>
<p>
But what kind of objects? The models in an MVC application are
supposed to be presentation-agnostic&mdash;they shouldn't know anything
about how to display themsevelves. And we know we don't want to put
business logic into the views. It seems like we need a third kind
of object between a Model and a View.
</p>

</div>

<div id="outline-container-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> Presenting the Presenter </h3>
<div class="outline-text-3" id="text-12-1">


<p>
One such type of object is called a <em>Presenter</em>. If the Model is
concerned with storing and manipulating business data, and the View is
concerned with displaying it, you can think of the Presenter as
standing between them deciding <em>which</em> data to show.
</p>
<p>
Presenter libraries for Rails have <a href="https://github.com/jcasimir/draper">started to pop up</a> lately, but for
this app we'll roll our own.  Let's first specify the behavior of a
Presenter for a "picture post".
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/presenters/picture_post_presenter_spec.rb</span>
require_relative <span class="org-string">'../spec_helper_lite'</span>
require_relative <span class="org-string">'../../app/presenters/picture_post_presenter'</span>

describe <span class="org-type">PicturePostPresenter</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@post</span> = <span class="org-type">OpenStruct</span>.new(
      title:   <span class="org-string">"TITLE"</span>, 
      body:    <span class="org-string">"BODY"</span>, 
      pubdate: <span class="org-string">"PUBDATE"</span>)
    <span class="org-variable-name">@template</span> = stub!
    <span class="org-variable-name">@it</span> = <span class="org-type">PicturePostPresenter</span>.new(<span class="org-variable-name">@post</span>, <span class="org-variable-name">@template</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"delegates method calls to the post"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.title.must_equal <span class="org-string">"TITLE"</span>
    <span class="org-variable-name">@it</span>.body.must_equal <span class="org-string">"BODY"</span>
    <span class="org-variable-name">@it</span>.pubdate.must_equal <span class="org-string">"PUBDATE"</span>
  <span class="org-keyword">end</span>

  it <span class="org-string">"renders itself with the appropriate partial"</span> <span class="org-keyword">do</span>
    mock(<span class="org-variable-name">@template</span>).render(
      partial: <span class="org-string">"/posts/picture_body"</span>, locals: {post: <span class="org-variable-name">@it</span>}){
      <span class="org-string">"THE_HTML"</span>
    }
    <span class="org-variable-name">@it</span>.render_body.must_equal <span class="org-string">"THE_HTML"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
We define stubs for both a "post" object, and a "template" object. The
<code>@post</code> stub stands in for a <code>Post</code> instance. The <code>@template</code> object
stands in for the Rails template object which is the context that all
views are rendered in. When you call helpers like <code>#render</code> or
<code>#form_for</code> in a Rails view, you're calling them on the template
object.
</p>
<p>
Then we specify that the presenter must 1) act as a "pass-through"
object, forwarding any methods it doesn't know about on to the model
object; and 2) that it must know how to use the template to render an
appropriate post body partial.
</p>
<p>
Next we write an implementation which satisfies this spec.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/presenters/picture_post_presenter.rb</span>
require <span class="org-string">'delegate'</span>
<span class="org-keyword">class</span> <span class="org-type">PicturePostPresenter</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(model, template)
    <span class="org-variable-name">@template</span> = template
    <span class="org-keyword">super</span>(model)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">render_body</span>
    <span class="org-variable-name">@template</span>.render(partial: <span class="org-string">"/posts/picture_body"</span>, locals: {post: <span class="org-variable-name">self</span>})
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
We've defined a new directory, <code>app/presenters</code>, for Presenter
objects. In it, we've created a <code>PicturePostPresenter</code> class.
</p>
<p>
This class inherits from <code>SimpleDelegator</code>. <code>SimpleDelegator</code> is Ruby
standard library class which has a very simple job: forward all calls
to an underlying object. Not very useful in and of itself; but as a
basis for defining <a href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</a> objects it's quite handy.
</p>
<p>
In the presenter initializer, we save the view template in an instance
variable. Then we call the <code>SimpleDelegator</code> initializer with <code>super</code>,
to set up delegation to the model object.
</p>
<p>
In the <code>#render_body</code> method, we use the saved <code>@template</code> to render a
partial for a picture-type post.
</p>
<p>
The presenter for text-only posts is nearly identical. Because it's so
similar, I'll omit the spec for it and just show the implementation:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">presenters/text_post_presenter.rb</span>
require <span class="org-string">'delegate'</span>
<span class="org-keyword">class</span> <span class="org-type">TextPostPresenter</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(model, template)
    <span class="org-variable-name">@template</span> = template
    <span class="org-keyword">super</span>(model)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">render_body</span>
    <span class="org-variable-name">@template</span>.render(partial: <span class="org-string">"/posts/text_body"</span>, locals: {post: <span class="org-variable-name">self</span>})
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
The only difference here is a different partial being rendered.
</p>
<p>
Now we need an easy way to wrap a model object in the appropriate
presenters (if any). Let's spec out a helper to do that:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/helpers/presenters_helper_spec.rb</span>
require_relative <span class="org-string">'../spec_helper_lite'</span>
require_relative <span class="org-string">'../../app/helpers/presenters_helper'</span>

stub_class <span class="org-string">'PicturePostPresenter'</span>
stub_class <span class="org-string">'TextPostPresenter'</span>
stub_class <span class="org-string">'Post'</span>

describe <span class="org-type">PresentersHelper</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">Object</span>.new
    <span class="org-variable-name">@it</span>.extend <span class="org-type">PresentersHelper</span>
    <span class="org-variable-name">@template</span> = stub!
  <span class="org-keyword">end</span>

  it <span class="org-string">"should decorate picture posts with a PicturePostPresenter"</span> <span class="org-keyword">do</span>
    post = <span class="org-type">Post</span>.new
    stub(post).picture?{<span class="org-variable-name">true</span>}
    <span class="org-variable-name">@it</span>.present(post, <span class="org-variable-name">@template</span>).must_be_kind_of(<span class="org-type">PicturePostPresenter</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"should decorate text posts with a TextPostPresenter"</span> <span class="org-keyword">do</span>
    post = <span class="org-type">Post</span>.new
    stub(post).picture?{<span class="org-variable-name">false</span>}
    <span class="org-variable-name">@it</span>.present(post, <span class="org-variable-name">@template</span>).must_be_kind_of(<span class="org-type">TextPostPresenter</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"should leave objects it doesn't know about alone"</span> <span class="org-keyword">do</span>
    model = <span class="org-type">Object</span>.new
    <span class="org-variable-name">@it</span>.present(model, <span class="org-variable-name">@template</span>).must_be_same_as(model)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
By it's nature, <code>PresentersHelper</code> is a piece of code which will have
to reference a lot of different classes, both model classes and
presenter classes. In order to avoid having test dependencies on all
those class definitions, we define and use a <code>#stub_class</code> test helper
which is almost identical in definition to the <code>#stub_module</code> method
we wrote before.
</p>
<p>
Here's helper code which satisfies the spec:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/helpers/presenters_helper.rb</span>
<span class="org-keyword">module</span> <span class="org-type">PresentersHelper</span>
  <span class="org-keyword">def</span> <span class="org-function-name">present</span>(model, template)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Doing a string comparison because of Rails class-reloading weirdness</span>
    <span class="org-keyword">case</span> model.class.name
    <span class="org-keyword">when</span> <span class="org-string">'Post'</span>
      <span class="org-keyword">if</span> model.picture?
        <span class="org-type">PicturePostPresenter</span>.new(model, template)
      <span class="org-keyword">else</span>
        <span class="org-type">TextPostPresenter</span>.new(model, template)
      <span class="org-keyword">end</span>
    <span class="org-keyword">else</span>
      model
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
<em>Hey, I thought we were getting *rid* of conditionals! That's just a giant mass of conditionals!</em> This is true. Unfortunately, it's not
always possible to completely eliminate type-based conditionals. What
we <em>can</em> do is isolate the conditionals to a single place, rather than
scattering them all over our view code. That's exactly what we're
trying to do here. Anywhere we might have done an <code>if...then...else</code>
in a view template based on an object's class or traits, we can
instead add a presenter to handle the conditional behavior
polymorphically. All the conditionals are consolidated on this one
helper method, which decides <em>which</em> presenter(s) to apply to a given
object.
</p>
<p>
The helper code above uses a <code>#picture?</code> predicate method on <code>Post</code>
objects. Let's quickly implement that.
</p>
<p>
Spec:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#picture?"</span> <span class="org-keyword">do</span>
  it <span class="org-string">"should be true when the post has a picture URL"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.image_url = <span class="org-string">"http://example.org/foo.png"</span>
    assert(<span class="org-variable-name">@it</span>.picture?)
  <span class="org-keyword">end</span>

  it <span class="org-string">"should be false when the post has no picture URL"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.image_url = <span class="org-string">""</span>
    refute(<span class="org-variable-name">@it</span>.picture?)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Implementation:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">picture?</span>
  image_url.present?
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>





<p>
Because we'll probably be using the <code>#present</code> helper method all over
the place in the future, we'll put it in our <code>ApplicationController</code>:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">ApplicationController</span> &lt; <span class="org-type">ActionController</span>::<span class="org-type">Base</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  helper <span class="org-constant">:presenters</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
Now, with our tiny homegrown presenter framework in place, we rewrite
the blog entry partial.
</p>



<pre class="src src-html">&lt;% entry = present(entry, self) %&gt;
&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">p</span>&gt;&lt;<span class="org-function-name">time</span> <span class="org-variable-name">pubdate</span>=<span class="org-string">"pubdate"</span>&gt;&lt;%= entry.pubdate %&gt;&lt;/<span class="org-function-name">time</span>&gt;&lt;/<span class="org-function-name">p</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= entry.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;%= entry.render_body %&gt;
&lt;/<span class="org-function-name">article</span>&gt;
</pre>




<p>
No more conditionals in the view! Just a simple method call to
<code>#render_body</code> which Does The Right Thing.
</p>
<p>
Here's how it looks when we post a picture: 
</p>
<p>
<img src="./images/wet-paint.png"  alt="./images/wet-paint.png" />
</p>
</div>

</div>

<div id="outline-container-12-2" class="outline-3">
<h3 id="sec-12-2"><span class="section-number-3">12.2</span> Refactoring the presenters </h3>
<div class="outline-text-3" id="text-12-2">

<p>The two presenters we defined are nearly identical. Clearly, they are
ripe for refactoring. Let's take care of that. We'll move the
commonalities into a <code>Presenter</code> base class:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/presenters/presenter.rb</span>
require <span class="org-string">'delegate'</span>
<span class="org-keyword">class</span> <span class="org-type">Presenter</span> &lt; <span class="org-type">SimpleDelegator</span>  
  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(model, template)
    <span class="org-variable-name">@template</span> = template
    <span class="org-keyword">super</span>(model)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
Now our presenters are are a lot slimmer:
</p>



<pre class="src src-ruby">require_relative <span class="org-string">'presenter'</span>

<span class="org-keyword">class</span> <span class="org-type">PicturePostPresenter</span> &lt; <span class="org-type">Presenter</span>
  <span class="org-keyword">def</span> <span class="org-function-name">render_body</span>
    <span class="org-variable-name">@template</span>.render(partial: <span class="org-string">"/posts/picture_body"</span>, locals: {post: <span class="org-variable-name">self</span>})
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
The specs we wrote earlier help ensure that we haven't broken anything
by performing this refactoring.
</p>
<p>
Before we move on, let's add a couple of extras to the <code>Presenter</code>
base class.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Presenter</span> &lt; <span class="org-type">SimpleDelegator</span>  
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">to_model</span>
    __getobj__
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">class</span>
    __getobj__.class
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
We don't have time to demonstrate it here, but these will help prevent
certain "gotchas" down the road. The first one defines <code>#to_model</code> to
return the wrapped model (the strange <code>#__getobj__</code> method is how
<code>SimpleDelegator</code> refers to its underlying object). The second one
redefines <code>#class</code> to return the class of the original model, instead
of the class of the presenter. Together, these methods will ensure
that Rails helpers such as <code>#form_for</code> don't get confused when they
encounter models wrapped in presenters.
</p>
</div>

</div>

<div id="outline-container-12-3" class="outline-3">
<h3 id="sec-12-3"><span class="section-number-3">12.3</span> Do we need helpers? </h3>
<div class="outline-text-3" id="text-12-3">


<p>
Our use of presenters raises the question: what do we need view
helpers for? Anything?
</p>
<p>
In my experience helpers in Rails apps tend to devolve into large,
disorganized bags of unrelated methods. Often these methods repeat the
same conditional business logic over and over again. For instance, how
many times have you seen helper code like this:
</p>



<pre class="src src-ruby"><span class="org-keyword">if</span> current_user.logged_in?
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">else</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
Thinning out helpers by taking some of their presentation
responsibilities away is not a bad thing, in my view.
</p>
<p>
That said, I don't think helpers are completely useless. They are a
good place to put general rendering methods which aren't tied to any
particular model. For instance, we could write a helper for displaying
HTML5-style images with captions:
</p>



<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">FigureHelper</span>
  <span class="org-keyword">def</span> <span class="org-function-name">figure</span>(image_path, caption)
    content_tag(<span class="org-constant">:figure</span>) <span class="org-keyword">do</span> 
      image_tag(image_path) +
        content_tag(<span class="org-constant">:figcaption</span>, caption)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
This helper generates markup that looks like this:
</p>



<pre class="src src-html">&lt;<span class="org-function-name">figure</span>&gt;
  &lt;<span class="org-function-name">img</span> <span class="org-variable-name">alt</span>=<span class="org-string">"freshpaint.jpg"</span> <span class="org-variable-name">src</span>=<span class="org-string">"http://example.org/f.jpg"</span> /&gt;
  &lt;<span class="org-function-name">figcaption</span>&gt;Fresh paint&lt;/<span class="org-function-name">figcaption</span>&gt;
&lt;/<span class="org-function-name">figure</span>&gt;
</pre>




<p>
This is pretty generic code, and I think it works well in a helper.
</p>
</div>
</div>

</div>

<div id="outline-container-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> Presenters for REST </h2>
<div class="outline-text-2" id="text-13">

<p>  Let's add a rudimentary RESTful API to our blog.
</p>
<p>
  Really RESTful APIs make heavy use of hyperlinking in the resource
  representations they serve. For instance, a JSON representation of a
  blog post might look something like this:
</p>



<pre class="src src-js">{
    <span class="org-string">"title"</span>: <span class="org-string">"Flakes"</span>,
    <span class="org-string">"body"</span>: <span class="org-string">"Uh oh, the paint is starting to flake!"</span>,
    <span class="org-string">"links"</span>: [
        {
            <span class="org-string">"rel"</span>: <span class="org-string">"next"</span>,
            <span class="org-string">"href"</span>: <span class="org-string">"http://example.org/blog/posts/3"</span>,
        },
        {
            <span class="org-string">"rel"</span>: <span class="org-string">"prev"</span>,
            <span class="org-string">"href"</span>: <span class="org-string">"http://example.org/blog/posts/1"</span>
        },
        {
            <span class="org-string">"rel"</span>: <span class="org-string">"up"</span>,
            <span class="org-string">"href"</span>: <span class="org-string">"http://example.org/blog/"</span>
        }
    ]
}
</pre>




<p>
  Constructing hyperlinked responses like this one presents us with a
  problem. Normally, when rendering HTML representations, we render
  links to other resources using the various routing helpers (such as
  <code>url_for</code> or <code>#post_url</code>) that Rails provides for us inside of view
  templates. But when we render JSON data, there typically <em>is</em> no
  view template.
</p>
<p>
  For instance, here's an implementation of <code>Post#show</code> that uses
  Rails' <code>#respond_with</code> method:
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">show</span>
  <span class="org-variable-name">@post</span> = <span class="org-type">Post</span>.find(params[<span class="org-constant">:id</span>])
  respond_with(<span class="org-variable-name">@post</span>)
<span class="org-keyword">end</span>
</pre>




<p>
  In the absence of a template at <code>[posts/show.json]</code>, a request for a
  post in JSON format will result in call to <code>Post#to_json</code>. 
</p>
<p>
  We'd like <code>Post#to_json</code> to provide a fully hyperlinked JSON
  representation as in the example above. But <code>Post</code> doesn't know
  anything about routing&hellip; and that's the way it should be! Once
  again, we need an object to mesh together information from a model
  and information from the framework. Once again, we need a Presenter.
</p>
<p>
  We could write a presenter specifically for converting <code>Post</code>
  objects to JSON. But it would be tedious writing presenters for each
  kind of model that we come up with, and in most cases the logic will
  probably be the same. So instead, we'll write a generic
  <code>LinksPresenter</code> which will work for most objects we throw at it. 
</p>
<p>
  We'll pick three simple link types to start with:
</p>
<ul>
<li>prev
</li>
<li>next
</li>
<li>up
</li>
</ul>


<p>
  These are three of the standard link types defined in the HTML4
  spec. When we serve a JSON representation of a blog post, we want to
  include a link to the next chronoloigical post, the preceding post,
  and the "parent" resource (<code>up</code>), which is the blog itself.
</p>
<p>
  The <code>LinkPresenter</code> class will take a model object and a template
  object, and adorn the model with <code>next_url</code>, <code>prev_url</code>, and
  <code>up_url</code> methods. It will also augment the <code>#to_json</code> method to
  include a list of links in the <a href="http://tools.ietf.org/html/draft-zyp-json-schema-03#section-6">JSON Hyper-Schema</a> style.
</p>
<p>
  The spec for <code>LinkPresenter</code> isn't that exciting, so I'll omit
  it. Here's the code:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">LinkPresenter</span> &lt; <span class="org-type">Presenter</span>
  <span class="org-type">RELATIONS</span> = %w[<span class="org-keyword">next</span> prev up]

  <span class="org-keyword">def</span> <span class="org-function-name">prev_url</span>
    <span class="org-variable-name">@template</span>.url_for(prev)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">next_url</span>
    <span class="org-variable-name">@template</span>.url_for(<span class="org-variable-name">self</span>.next)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">up_url</span>
    <span class="org-variable-name">@template</span>.url_for(up)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">links_hash</span>
    {
      <span class="org-string">"links"</span> =&gt; <span class="org-type">RELATIONS</span>.map { |rel|
        {<span class="org-string">"rel"</span> =&gt; rel, <span class="org-string">"href"</span> =&gt; send(<span class="org-string">"</span><span class="org-variable-name">#{rel}</span><span class="org-string">_url"</span>)}
      }
    }
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">serializable_hash</span>(*args)
    <span class="org-keyword">super</span>.merge(links_hash)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">to_json</span>(options={})
    serializable_hash(options).to_json
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
  In order to generate URLs, the <code>LinkPresenter</code> relies on the model
  to respond to three methods, unsurprisingly called <code>#prev</code>, <code>#next</code>,
  and <code>#up</code>. These methods are expected to return the model object
  with the specified relationship to the receiver.
</p>
<p>
  Implementing these methods for <code>Post</code> is straightforward:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">self.first_before</span>(date)
  first(conditions: [<span class="org-string">"pubdate &lt; ?"</span>, date],
        order:      <span class="org-string">"pubdate DESC"</span>)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">self.first_after</span>(date)
  first(conditions: [<span class="org-string">"pubdate &gt; ?"</span>, date],
        order:      <span class="org-string">"pubdate ASC"</span>)
<span class="org-keyword">end</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

<span class="org-keyword">def</span> <span class="org-function-name">prev</span>
  <span class="org-variable-name">self</span>.class.first_before(pubdate)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">next</span>
  <span class="org-variable-name">self</span>.class.first_after(pubdate)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">up</span>
  <span class="org-type">THE_BLOG</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
  Remember, we're avoiding exposing ActiveRecord built-in methods in
  the <code>Post</code> public API, so we have to define explicit class-level
  finder methods to retrieve the posts preceding and following a given
  date. By defining explicit finders (<code>.first_before</code> and
  <code>.first_after</code>) with constrained parameters, we keep the <code>Post</code>
  interface manageable.
</p>
<p>
  We update the <code>#present</code> method in <code>PresentersHelper</code> to add a
  <code>LinkPresenter</code> to <code>Post</code> objects:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">when</span> <span class="org-string">'Post'</span>
  model = <span class="org-keyword">if</span> model.picture?
            <span class="org-type">PicturePostPresenter</span>.new(model, template)
          <span class="org-keyword">else</span>
            <span class="org-type">TextPostPresenter</span>.new(model, template)
          <span class="org-keyword">end</span>
  <span class="org-type">LinkPresenter</span>.new(model, template)
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
  Then we modify <code>PostsController</code> to expose a <code>#show</code> method.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">PostsController</span> &lt; <span class="org-type">ApplicationController</span>
  respond_to <span class="org-constant">:html</span>, <span class="org-constant">:json</span>

  include <span class="org-type">PresentersHelper</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-keyword">def</span> <span class="org-function-name">show</span>
    <span class="org-variable-name">@post</span> = present(<span class="org-type">Post</span>.find_by_id(params[<span class="org-constant">:id</span>]), <span class="org-variable-name">self</span>)
    respond_with(<span class="org-variable-name">@post</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
  We've made a few modifications here. First, we've used <code>respond_to</code>
  to indicate that this controller can serve resources using JSON
  representations. Then we've included the <code>PresentersHelper</code> so as to
  give the controller access to <code>#present</code>. Finally, we've implemented
  a <code>#show</code> method which finds the indicated <code>Post</code>, runs it through
  <code>present()</code> to wrap it in all appropriate presenters, and then uses
  <code>respond_with</code> to hook into Rails' automatic content negotiation
  system.
</p>
<p>
  If you're following along carefully, you might be wondering about
  using <code>PresentersHelper#present</code> in a Controller, where before we only used it in
  views. In particular, does it work to pass a controller as the
  <code>template</code> argument to <code>PresentersHelper#present</code>?
</p>
<p>
  While it's called <code>template</code>, the <code>template</code> parameter can really be
  anything which responds to the various helper methods used by
  presenters. In this case, the only presenter being called upon is
  <code>LinkPresenter</code>, and the only helper method it needs from the
  <code>template</code> is <code>#url_for</code>. Since <code>#url_for</code> is available in controllers
  as well as in views, everything works out.
</p>
<p>
  Well, almost. One of the things <code>LinksPresenter</code> will be calling
  <code>#url_for</code> on is a post's <code>#up</code> relation, which is the global <code>Blog</code>
  instance. As you'll recall, <code>Blog</code> is just an ordinary object, not
  an ActiveRecord. As such, Rails has no idea how to convert it to a
  route in <code>#url_for</code>.
</p>
<p>
  I looked for a way to neatly hook into the machinery Rails uses to
  map from the arguments to <code>#url_for</code> to a route and then to a
  URL. Unfortunately I wasn't able to find anything. The solution I
  settled on is a bit of a kludge. In <code>ApplicationController</code>, we
  redefine <code>#url_for</code> to handle the <code>Blog</code> special case:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">url_for</span>(*args)
  <span class="org-comment-delimiter"># </span><span class="org-comment">use string matching to avoid dev-mode autoloading issues</span>
  <span class="org-keyword">if</span> args.size == 1 &amp;&amp; args.first.class.name == <span class="org-string">'Blog'</span>
    root_url
  <span class="org-keyword">else</span>
    <span class="org-keyword">super</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
  If you know of a better solution, please get in touch!
</p>
<p>
  We're now all set up to serve out JSON versions of blog posts. When
  we create a few posts and then point <code>curl</code> at
  <code>http://localhost:3000/posts/2.json</code>, here's what we get:
</p>



<pre class="src src-js">{
  <span class="org-string">"body"</span>: <span class="org-string">"This is the second post. Establishing a pattern here!"</span>, 
  <span class="org-string">"created_at"</span>: <span class="org-string">"2011-11-14T23:53:16Z"</span>, 
  <span class="org-string">"id"</span>: 2, 
  <span class="org-string">"image_url"</span>: <span class="org-string">""</span>, 
  <span class="org-string">"links"</span>: [
      {
          <span class="org-string">"href"</span>: <span class="org-string">"http://localhost:3000/posts/3"</span>, 
          <span class="org-string">"rel"</span>: <span class="org-string">"next"</span>
      }, 
      {
          <span class="org-string">"href"</span>: <span class="org-string">"http://localhost:3000/posts/1"</span>, 
          <span class="org-string">"rel"</span>: <span class="org-string">"prev"</span>
      }, 
      {
          <span class="org-string">"href"</span>: <span class="org-string">"http://localhost:3000/"</span>, 
          <span class="org-string">"rel"</span>: <span class="org-string">"up"</span>
      }
  ], 
  <span class="org-string">"pubdate"</span>: <span class="org-string">"2011-11-14T23:53:16Z"</span>, 
  <span class="org-string">"title"</span>: <span class="org-string">"Second post"</span>, 
  <span class="org-string">"updated_at"</span>: <span class="org-string">"2011-11-14T23:53:16Z"</span>
}
</pre>




<p>
  That's just a beginning. I'm sure you can imagine how we might
  expand this out to include a JSON version of the home page, which
  contains links to individual posts, and so on.
</p></div>

</div>

<div id="outline-container-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> Making the data stick around </h2>
<div class="outline-text-2" id="text-14">


<p>
Posts, time stamps, reverse-chronological sorting, image
posting&hellip; we're well on our way to a working blog engine. But I feel
like there's something missing. Some little detail, if I could just
put my finger on it&hellip;
</p>
<p>
&hellip;oh yeah, <strong>persistence</strong>! It would probably be good if our blog posts
lasted longer than run-time of the application server.
</p>
<p>
If you've been following along wondering "where's the ActiveRecord?",
this is where we get to it. Now that we have figured out what our
domain model looks like, it's time to start serializing the models to
a database.
</p>
<p>
But first, a little philosophizing.
</p>

</div>

<div id="outline-container-14-1" class="outline-3">
<h3 id="sec-14-1"><span class="section-number-3">14.1</span> The trouble with ActiveRecord </h3>
<div class="outline-text-3" id="text-14-1">


<p>
ActiveRecord is an <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">Object-Relational Mapper</a> (ORM) based on the <a href="http://martinfowler.com/eaaCatalog/activeRecord.html">Active Record</a>
pattern from <a href="http://www.martinfowler.com/books.html#eaa">Patterns of Enterprise Application Architecture</a>. As an
ORM, it is semi-orthogonal to the business logic of your
application. ORMs handle the loading and saving of objects to records
in a database. The behavior of those objects, apart from persistence,
is (theoretically) outside of the ORM's responsibilities.
</p>
<p>
In practice, real world Rails-based projects tend to be almost
inextricably coupled to the ActiveRecord library. And not just to
ActiveRecord; AR-based apps also tend to have very tight
intercoupling between the various models in the system. In
pathological cases, controllers and even views are also tightly
married to the details of ActiveRecord and database schema.
</p>
<p>
Part of this is doubtless due to the way ActiveRecord integrates with
models. By declaring an <a href="http://en.wikipedia.org/wiki/Is-a">is-a</a> relationship between ActiveRecord and
model classes, your models are no longer just domain models; they
effectively <em>are</em> ActiveRecord. One result of this tight coupling is
that novice and intermediate Rails developers are often surprised to
find out that it's even <em>permissible</em> to have model objects which do
not inherit from <code>ActiveRecord::Base</code>. And even after they learn this
they sometimes still exile their non-ActiveRecord models to the <code>lib/</code>
ghetto, denying them their true place in <code>app/models</code>.
</p>
<p>
Consider the case of the <code>#find</code> method. By inheriting from
<code>ActiveRecord::Base</code>, you declare that your model supports
<code>#find</code>. Find supports (at last count) four modes (<code>:id</code>, <code>:first</code>,
<code>:last</code>, and <code>:all</code>), each of which can take any of twelve different
options. Some of the options, such as <code>:conditions</code>, can accept an
effectively limitless range of values.
</p>
<p>
<code>#find</code> is, in effect, an <em>infinite protocol</em>. This presents some
serious difficulties. Many Rails developers have discovered, for
instance, that it is very difficult to write meaningful ActiveRecord
mock objects in their tests. If they stictly specify all of the
<code>#find</code> arguments that their method-under-test must pass, they are
essentially dictating the implementation of the method in the
test. If, on the other hand, they stick with pure stubs which will
accept any possible call to <code>#find</code>, their tests are less brittle, but
also less useful because they don't actually specify much.
</p>
<p>
As a result, a lot of developers resort to running all of their unit
tests as what are, in effect, integration tests, with "real"
collaborator objects and full database interactions. The result, on
the testing side, is slow tests. The result on the application code
side is classes that freely call <code>#find</code> and friends on a half-a-dozen
different collaborator classes&mdash;thus ensuring that future
refactorings will be a slow and tedious process akin to un-teasing
thickly matted dreadlocks.
</p>
<p>
One day, after years of witnessing and addressing the technical debt
incurred in various maturing Rails codebases as a result of
ActiveRecord-inspired tight coupling, I had an epiphany. What if we
stopped treating ActiveRecord as the backbone of our model classes,
and instead, programmed <em>as if</em> ActiveRecord were merely a private
implementation detail?
</p>
<p>
And this is why we have, so far, programmed this application without
once touching ActiveRecord. We've worked through the object
representation of domain concepts&mdash;blog, posts, publishing,
etc&mdash;using traditional object-oriented analysis and development.
</p>
<p>
Now we'll add persistence to the mix. We'll use ActiveRecord, because
it is both convenient and powerful. But we'll attempt to do it in
a way that treats it as an internal concern to our models, not as the
backbone of our design.
</p>
</div>

</div>

<div id="outline-container-14-2" class="outline-3">
<h3 id="sec-14-2"><span class="section-number-3">14.2</span> Adding ActiveRecord </h3>
<div class="outline-text-3" id="text-14-2">


<p>
Looking at our models, it's pretty clear that we need a "posts" table
to hold blog posts. So we'll start by creating a migration to create
that table.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">CreatePosts</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Migration</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.up</span>
    create_table <span class="org-constant">:posts</span> <span class="org-keyword">do</span> |t|
      t.datetime <span class="org-constant">:pubdate</span>
      t.string <span class="org-constant">:title</span>
      t.text <span class="org-constant">:body</span>
      t.string <span class="org-constant">:image_url</span>

      t.timestamps
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.down</span>
    drop_table <span class="org-constant">:posts</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
Once we run this migration, we have a place to keep our blog
posts. Now we need to make the <code>Post</code> model store itself there.
</p>
<p>
We need to make several changes to the <code>Post</code> and <code>Blog</code> code.
</p>



<pre class="src src-ruby">require <span class="org-string">'date'</span>
require <span class="org-string">'active_record'</span>

<span class="org-keyword">class</span> <span class="org-type">Post</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  validates <span class="org-constant">:title</span>, <span class="org-constant">:presence</span> =&gt; <span class="org-variable-name">true</span>

  attr_accessor <span class="org-constant">:blog</span>

  <span class="org-keyword">def</span> <span class="org-function-name">picture?</span>
    image_url.present?
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">publish</span>(clock=<span class="org-type">DateTime</span>)
    <span class="org-keyword">return</span> <span class="org-variable-name">false</span> <span class="org-keyword">unless</span> valid?
    <span class="org-variable-name">self</span>.pubdate = clock.now
    <span class="org-variable-name">@blog</span>.add_entry(<span class="org-variable-name">self</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<ul>
<li><code>Post</code> now inherits from <code>ActiveRecord::Base</code>. We require
  <code>active_record</code> for when we are running tests in isolation.
</li>
<li>The various individual ActiveModel mixins are gone, subsumed into
  <code>ActiveRecord::Base</code>.
</li>
<li>No more attribute accessors for <code>title</code>, <code>body</code>, and
  <code>image_url</code>. Those are handled by ActiveRecord now.
</li>
<li>No more initializer. Its former functionality is rendered redundant
  by the AR intializer.
</li>
<li><code>#persisted?</code> is gone too, for the same reason.
</li>
</ul>


<p>
Moving on to <code>Blog</code>:
</p>



<pre class="src src-ruby"><span class="linenr"> 1:  </span><span class="org-keyword">class</span> <span class="org-type">Blog</span>
<span class="linenr"> 2:  </span>  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(entry_fetcher=<span class="org-type">Post</span>.public_method(<span class="org-constant">:all</span>)) <span class="org-comment-delimiter"># </span><span class="org-comment">(ref:default_fetcher)</span>
<span class="linenr"> 5:  </span>    <span class="org-variable-name">@entry_fetcher</span> = entry_fetcher <span class="org-comment-delimiter"># </span><span class="org-comment">(ref:fetcher)</span>
<span class="linenr"> 6:  </span>  <span class="org-keyword">end</span>
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="linenr"> 9:  </span>
<span class="linenr">10:  </span>  <span class="org-keyword">def</span> <span class="org-function-name">entries</span>
<span class="linenr">11:  </span>    fetch_entries.sort_by{|e| e.pubdate}.reverse.take(10) <span class="org-comment-delimiter"># </span><span class="org-comment">(ref:entries)</span>
<span class="linenr">12:  </span>  <span class="org-keyword">end</span>
<span class="linenr">13:  </span>
<span class="linenr">14:  </span>  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="linenr">15:  </span>
<span class="linenr">16:  </span>  <span class="org-keyword">def</span> <span class="org-function-name">add_entry</span>(entry)
<span class="linenr">17:  </span>    entry.save                  <span class="org-comment-delimiter"># </span><span class="org-comment">(ref:entry_save)</span>
<span class="linenr">18:  </span>  <span class="org-keyword">end</span>
<span class="linenr">19:  </span>
<span class="linenr">20:  </span>  <span class="org-keyword">private</span>
<span class="linenr">21:  </span>
<span class="linenr">22:  </span>  <span class="org-keyword">def</span> <span class="org-function-name">fetch_entries</span>
<span class="linenr">23:  </span>    <span class="org-variable-name">@entry_fetcher</span>.()
<span class="linenr">24:  </span>  <span class="org-keyword">end</span>
<span class="linenr">25:  </span>
<span class="linenr">26:  </span>  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="linenr">27:  </span><span class="org-keyword">end</span>
</pre>




<ul>
<li>The <code>@entries</code> instance variable, which used to point to an array of
  entries, is gone. In it's place is an <code>@entry_fetcher</code> variable
  (line <a href="#coderef-fetcher" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-fetcher');" onmouseout="CodeHighlightOff(this, 'coderef-fetcher');">nil</a>). We're using this variable to make the strategy for
  finding blog entries an injectable dependency. This will make
  testing the class easier.
</li>
<li>Since posts live in the database now, the default method for
  fetching a list of entries is to call <code>Post.all</code> (line
  <a href="#coderef-default_fetcher" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-default_fetcher');" onmouseout="CodeHighlightOff(this, 'coderef-default_fetcher');">nil</a>).
</li>
<li>Apart from using the entry fetcher instead of referencing the
  <code>@entries</code> list directly, the <code>entries</code> method has changed
  suprisingly little (line <a href="#coderef-entries" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-entries');" onmouseout="CodeHighlightOff(this, 'coderef-entries');">nil</a>). Because the result of
  ActiveRecord's <code>#all</code> is <code>Enumerable</code>, we can still use the same
  sorting and filtering methods we used before. It's not efficient,
  but it works for now.
</li>
<li><code>#add_entry</code>, instead of adding the post to an internal list, now
  calls <code>#save</code> on the passed entry (line <a href="#coderef-entry_save" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-entry_save');" onmouseout="CodeHighlightOff(this, 'coderef-entry_save');">(entry<sub>save</sub>)</a>).
</li>
</ul>


</div>

</div>

<div id="outline-container-14-3" class="outline-3">
<h3 id="sec-14-3"><span class="section-number-3">14.3</span> Why does <code>Blog</code> do the saving? </h3>
<div class="outline-text-3" id="text-14-3">


<p>
That last item warrants some more discussion. Originally,
<code>Blog#add_entry</code> was needed because <code>Blog</code> maintained an internal list
of entries. But now that posts are stored in the DB, can't we just
call <code>#save</code> on them directly from <code>Post#publish</code>, and do away with
<code>Blog#add_entry</code>?
</p>
<p>
Here's the thing: while the data storage strategy has changed, the
conceptual model of the application ought to stay the same. And that
model is that a <code>Blog</code> is the top-level object in the app, and it is
responsible for creating and maintaing a list of blog entries.
</p>
<p>
Does it really matter who does the saving? Consider this: supposing
one day we decide to add a feature where our blog will send
notifications to our social networking accounts (Twitter, Facebook,
etc.) whenever a new post is published. This is publishing of
notifications should probably be accessible from the top-level
blog object, since it will presumably have references to the needed
account information objects. Let's say there's a
<code>Blog#spam_social_networks(entry)</code> method.
</p>
<p>
If Posts are responsible for saving themselves, the <code>Blog</code> object will
have no way of knowing when a new post goes up, and therefore needs to
be broadcast. Which means we'd probably wind up adding an after<sub>save</sub>
hook in <code>Post</code>, something like this:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  after_save <span class="org-constant">:broadcast_entry</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">private</span>

  <span class="org-keyword">def</span> <span class="org-function-name">broadcast_entry</span>
    blog.spam_social_networks(<span class="org-variable-name">self</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
The trouble is, spamming social networks is almost entirely orthogonal
to a <code>Post</code>'s primary responsibility of representing a blog post. The
origins of many a bloated model can be traced back to this kind of
gradual responsibility creep.
</p>
<p>
When we keep the conceptual responsibility of adding a new post on the
<code>Blog</code>, there's no need for callbacks:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">add_entry</span>(entry)
<span id="coderef-entry_save" class="coderef-off">  entry.save                  <span class="org-comment-delimiter"># </span><span class="org-comment">(entry_save)</span></span>
  spam_social_networks(entry)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
That's shorter and (I'd argue) a better place for the code. The larger
point here is that by first building up our domain models divorced
from persistence concerns, we came up with a design that closely
matches our mental picture of the problem. As a result, new features
that are still consistent with our original conception of the problem
space tend to slot in neatly.
</p>
<p>
(You might be objecting "but wait! Now <code>Blog</code> has two
responsibilities!" This is true, and a fair point. We can
optimistically imagine that <code>#spam_social_networks</code> is only an entry
point to a third object whose sole responsibility is sending out
notifications.)
</p>
</div>

</div>

<div id="outline-container-14-4" class="outline-3">
<h3 id="sec-14-4"><span class="section-number-3">14.4</span> Updating the <code>Blog</code> tests </h3>
<div class="outline-text-3" id="text-14-4">


<p>
As you might imagine, we need to make a number of changes to the
<code>Post</code> and <code>Blog</code> specs to adapt them to these changes. We'll start
with <code>Blog</code>.
</p>
<p>
First of all, in creating a <code>Blog</code> instance to test, we now supply our
own entries list instead of letting it reach out to <code>Post</code> for the
list.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
before <span class="org-keyword">do</span>
  <span class="org-variable-name">@entries</span> = []
  <span class="org-variable-name">@it</span> = <span class="org-type">Blog</span>.new(-&gt;{<span class="org-variable-name">@entries</span>})
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
And instead of asserting that <code>#add_entry</code> adds an item to an internal
list, we now assert that it calls <code>#save</code> to add the entry:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#add_entry"</span> <span class="org-keyword">do</span>
  it <span class="org-string">"should add the entry to the blog"</span> <span class="org-keyword">do</span>
    entry = stub!
    mock(entry).save
    <span class="org-variable-name">@it</span>.add_entry(entry)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
If you recall, the tests for <code>Blog</code> also specify that it must return
only 10 entries from <code>#entries</code>, and they must be sorted in
reverse-chronological order. We could inject a fake entries collection
into the object and continue to test it as we did before. But this
would make for a fragile test. We probably want to change the
<code>Enumerable</code> code to native <code>ActiveRecord</code> filtering/limiting calls at
some point in the future. At that point our specs would break.
</p>
<p>
One option is that we simply remove the specs when that happens, since
we trust that ActiveRecord will implement sorting and filtering
correctly. But do we trust ourselves to call ActiveRecord correctly?
</p>
<p>
Instead, what we'll do is move these specs from the current isolated
unit test into a separate <code>Blog</code> integration test suite. This suite
will hit the actual database.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/blog_integration_spec.rb</span>
require_relative <span class="org-string">'../spec_helper_full'</span>

describe <span class="org-type">Blog</span> <span class="org-keyword">do</span>
  include <span class="org-type">SpecHelpers</span>
  before <span class="org-keyword">do</span>
    setup_database
    <span class="org-variable-name">@it</span> = <span class="org-type">Blog</span>.new
  <span class="org-keyword">end</span>

  after <span class="org-keyword">do</span>
    teardown_database
  <span class="org-keyword">end</span>

  describe <span class="org-string">"#entries"</span> <span class="org-keyword">do</span>
    <span class="org-keyword">def</span> <span class="org-function-name">make_entry_with_date</span>(date)
      <span class="org-variable-name">@it</span>.new_post(<span class="org-constant">:pubdate</span> =&gt; <span class="org-type">DateTime</span>.parse(date), <span class="org-constant">:title</span> =&gt; date)
    <span class="org-keyword">end</span>

    it <span class="org-string">"should be sorted in reverse-chronological order"</span> <span class="org-keyword">do</span>
      oldest = make_entry_with_date(<span class="org-string">"2011-09-09"</span>)
      newest = make_entry_with_date(<span class="org-string">"2011-09-11"</span>)
      middle = make_entry_with_date(<span class="org-string">"2011-09-10"</span>)

      <span class="org-variable-name">@it</span>.add_entry(oldest)
      <span class="org-variable-name">@it</span>.add_entry(newest)
      <span class="org-variable-name">@it</span>.add_entry(middle)
      <span class="org-variable-name">@it</span>.entries.must_equal([newest, middle, oldest])
    <span class="org-keyword">end</span>

    it <span class="org-string">"should be limited to 10 items"</span> <span class="org-keyword">do</span>
      10.times <span class="org-keyword">do</span> |i|
        <span class="org-variable-name">@it</span>.add_entry(make_entry_with_date(<span class="org-string">"2011-09-</span><span class="org-variable-name">#{i+1}</span><span class="org-string">"</span>))
      <span class="org-keyword">end</span>
      oldest = make_entry_with_date(<span class="org-string">"2011-08-30"</span>)
      <span class="org-variable-name">@it</span>.add_entry(oldest)
      <span class="org-variable-name">@it</span>.entries.size.must_equal(10)
      <span class="org-variable-name">@it</span>.entries.wont_include(oldest)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
This spec will continue to specify the expected order and collection
size regardless of how the selection is accomplished inside <code>Blog</code>.
</p>
</div>

</div>

<div id="outline-container-14-5" class="outline-3">
<h3 id="sec-14-5"><span class="section-number-3">14.5</span> Separating out integration tests </h3>
<div class="outline-text-3" id="text-14-5">


<p>
This is a technique I often use in the apps I work on. Separating unit
tests from integration tests puts a clear divider between the tests
that verify that our database interactions are doing what we think
they are doing, from the tests that specify what logic our models
should implement.
</p>
<p>
It also makes it very easy to run <em>only</em> the fast, isolated tests; or
<em>only</em> the slow, DB-bound tests. Keeping as many of our tests as
possible in super-fast isolation means we can complete the
red-green-refactor cycle in seconds rather than minutes.
</p>
<p>
You may have notices some new methods being called in the <code>before</code> and
<code>after</code> blocks. These ensure that the database contents is blown away
before and after test runs. Here are the definitions:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/spec_helper_full.rb</span>
require_relative <span class="org-string">'spec_helper_lite'</span>
require_relative <span class="org-string">'../config/environment.rb'</span>

<span class="org-keyword">module</span> <span class="org-type">SpecHelpers</span>
  <span class="org-keyword">def</span> <span class="org-function-name">setup_database</span>
    <span class="org-type">DatabaseCleaner</span>.strategy = <span class="org-constant">:transaction</span>
    <span class="org-type">DatabaseCleaner</span>.clean_with(<span class="org-constant">:truncation</span>)
    <span class="org-type">DatabaseCleaner</span>.start
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">teardown_database</span>
    <span class="org-type">DatabaseCleaner</span>.clean
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>



</div>

</div>

<div id="outline-container-14-6" class="outline-3">
<h3 id="sec-14-6"><span class="section-number-3">14.6</span> Updating the <code>Post</code> tests </h3>
<div class="outline-text-3" id="text-14-6">


<p>
The majority of changes we make to the <code>Post</code> tests are removals. For
instance, this test asserts that we can pass attributes into
<code>Post#new</code>:
</p>



<pre class="src src-ruby">it <span class="org-string">"should support setting attributes in the initializer"</span> <span class="org-keyword">do</span>
  it = <span class="org-type">Post</span>.new(<span class="org-constant">:title</span> =&gt; <span class="org-string">"mytitle"</span>, <span class="org-constant">:body</span> =&gt; <span class="org-string">"mybody"</span>)
  it.title.must_equal <span class="org-string">"mytitle"</span>
  it.body.must_equal <span class="org-string">"mybody"</span>
<span class="org-keyword">end</span>
</pre>




<p>
We are reasonably confident that this functionality Just Works in
ActiveRecord, so we trash the test.
</p>
<p>
Throwing away tests&hellip; does this mean that the test was a waste of
time? No, it served its purpose. We're using tests primarily for the
sake of driving design, so even if we threw them all out right now
they would still have played their part. Of course, it's also nice to
have them around to catch regressions; but deleting the odd test
should not be cause for consternation.
</p>
<p>
<code>Post</code> is now an <code>ActiveRecord::Base</code> derivative, which means it's
going to be trying to talk to the database all the time. How can we
continue to test it in isolation? We'll use a couple of strategies to
make that work.
</p>
<p>
First, remember how we said we were going to treat ActiveRecord as an
implementation detail rather than as an essential part of the model?
Now we put those words into action. Here's the top-level setup block
for <code>Post</code> tests:
</p>



<pre class="src src-ruby">before <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-variable-name">@it</span> = <span class="org-type">Post</span>.new(<span class="org-constant">:title</span> =&gt; <span class="org-string">"TITLE"</span>)
  <span class="org-variable-name">@ar</span> = <span class="org-variable-name">@it</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
In this setup block, we take a second reference to the object being
tested and call it <code>@ar</code>. It's actually the same object, but we'll use
it for creating mocks and stubs of ActiveRecord-provided methods. We
want to treat ActiveRecord as just another collaborator, and the <code>@ar</code>
alias helps us make that delineation more "real".
</p>
<p>
Here's an example where we use the alias:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
before <span class="org-keyword">do</span>
  stub(<span class="org-variable-name">@ar</span>).valid?{<span class="org-variable-name">false</span>}
<span class="org-keyword">end</span>

it <span class="org-string">"should not add the post to the blog"</span> <span class="org-keyword">do</span>
  dont_allow(<span class="org-variable-name">@blog</span>).add_entry
  <span class="org-variable-name">@it</span>.publish
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
We want to simulate the case where the object is invalid. Since
validity checking is provided by ActiveRecord, we treat it as an
external dependency and stub it out with
<code>stub(@ar).valid?{false}</code>. Then we attempt to publish the post, and
verify that in an invalid state the post will not be added to the
blog.
</p>
<p>
Secondly, in order to avoid the overhead of connecting to a real
database, we use <a href="https://github.com/nulldb/nulldb">NullDB</a> to set up a do-nothing database connection before
running the specs.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
before <span class="org-keyword">do</span>
  setup_nulldb
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

after <span class="org-keyword">do</span>
  teardown_nulldb
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
These helpers are defined in <code>spec_helper_lite.rb</code>:
</p>



<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">SpecHelpers</span>
  <span class="org-keyword">def</span> <span class="org-function-name">setup_nulldb</span>
    schema_path = <span class="org-type">File</span>.expand_path(<span class="org-string">'../db/schema.rb'</span>, 
                                   <span class="org-type">File</span>.dirname(__FILE__))
    <span class="org-type">NullDB</span>.nullify(<span class="org-constant">:schema</span> =&gt; schema_path)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">teardown_nulldb</span>
    <span class="org-type">NullDB</span>.restore
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




</div>

</div>

<div id="outline-container-14-7" class="outline-3">
<h3 id="sec-14-7"><span class="section-number-3">14.7</span> Using ActivRecord objects as data access objects </h3>
<div class="outline-text-3" id="text-14-7">


<p>   
   In the code above we constructed a <a href="http://en.wikipedia.org/wiki/Chinese_wall">chinese wall</a> between the bits of
   the model that ActiveRecord provides, and the bits that we
   provide. Some Rails practitioners prefer to set up a stricter
   division between business logic and storage logic.
</p>
<p>
   In order to accomplish this, they create separate business model
   objects which keep an internal reference to an ActiveRecord
   object. The ActiveRecord object is kept intentionally "skinny",
   containing only associations, scopes, and validations. The business
   model object delegates its storage to the AR object, but handles
   everything else internally. The ActiveRecord object becomes a way
   to get at the stored data, and nothing more.
</p>
<p>
   Piotr Solinica has <a href="http://solnic.eu/2011/08/01/making-activerecord-models-thin.html">a great post</a> about this pattern. Personally, I
   think this is a promising technique for separating concerns. But I
   also think it may be a bit heavyweight for some apps. In the code
   above I've tried to strike a middle ground, using convention more
   than hard object divisions to separate the concerns, and not
   straying too far from Rails norms. A little later on, once we get
   into tagging, we'll revisit this idea of using ActiveRecord as just
   a thin layer over database rows.
</p>
</div>
</div>

</div>

<div id="outline-container-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> Concealing ActiveRecord behind a <code>FigLeaf</code> </h2>
<div class="outline-text-2" id="text-15">

<p>  So far, our attempts to treat ActiveRecord as a private
  implementation detail have been by convention, rather than enforced
  by the framework. It would be nice if we could get some validation
  that we are in fact obeying the rules we've set for ourselves.
</p>
<p> 
  I've written a tool to make this possible, called <code>FigLeaf</code>. The
  code is fairly short, although it may be a bit daunting if you
  haven't done a lot of Ruby metaprogramming.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">Tools for making inherited interfaces private to a class.</span>
<span class="org-keyword">module</span> <span class="org-type">FigLeaf</span>
  <span class="org-keyword">module</span> <span class="org-type">Macros</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Given a list of classes, modules, strings, and symbols, compile</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">a combined list of methods. Classes and modules will be queried</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">for their instance methods; strings and symbols will be treated</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">as method names. </span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Once the list is compiled, make all of the methods private.</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Takes an optional options hash, which can include the following options:</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">- :ancestors is a boolean determining whether to consider</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">ancestors classes and modules.</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">- :except is a list of classes, modules, and method names which</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">will be excluded from treatment.</span>
    <span class="org-keyword">def</span> <span class="org-function-name">hide</span>(*stuff)
      hide_methods(<span class="org-variable-name">self</span>, [<span class="org-type">Object</span>], *stuff)
    <span class="org-keyword">end</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Like #hide, only hides methods at the class/module level.</span>
    <span class="org-keyword">def</span> <span class="org-function-name">hide_singletons</span>(*stuff)
      hide_methods(singleton_class, [<span class="org-type">Class</span>], *stuff)
    <span class="org-keyword">end</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">The shared bits of #hide and #hide_singletons</span>
    <span class="org-keyword">def</span> <span class="org-function-name">hide_methods</span>(mod, except_defaults, *stuff)
      options = stuff.last.is_a?(<span class="org-type">Hash</span>) ? stuff.pop : {}
      include_ancestors  = options.fetch(<span class="org-constant">:ancestors</span>){<span class="org-variable-name">false</span>}
      except             = <span class="org-type">Array</span>(options.fetch(<span class="org-constant">:except</span>){except_defaults})
      protect            = <span class="org-type">Array</span>(options[<span class="org-constant">:protect</span>])
      except_methods     = collect_methods(<span class="org-variable-name">true</span>, *except)
      protect_methods    = collect_methods(<span class="org-variable-name">true</span>, *protect)
      hide_methods       = collect_methods(include_ancestors, *stuff)
      (hide_methods - except_methods).each <span class="org-keyword">do</span> |method_name|
        mod.module_eval <span class="org-keyword">do</span> 
          <span class="org-keyword">next</span> <span class="org-keyword">unless</span> method_defined?(method_name)
          <span class="org-keyword">if</span> protect_methods.include?(method_name)
            <span class="org-keyword">protected</span> method_name
          <span class="org-keyword">else</span>
            <span class="org-keyword">private</span> method_name
          <span class="org-keyword">end</span>
        <span class="org-keyword">end</span>
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Given a list of classes, modules, strings, and symbols, compile</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">a combined list of methods. Classes and modules will be queried</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">for their instance methods; strings and symbols will be treated</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">as methods names. +include_ancestors+ determines whether to</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">include methods defined by class/module ancestors.</span>
    <span class="org-keyword">def</span> <span class="org-function-name">collect_methods</span>(include_ancestors, *methods_or_modules)
      methods_or_modules.inject([]) {|methods, method_or_module|
        <span class="org-keyword">case</span> method_or_module
        <span class="org-keyword">when</span> <span class="org-type">Symbol</span>, <span class="org-type">String</span>
          methods &lt;&lt; method_or_module.to_sym
        <span class="org-keyword">when</span> <span class="org-type">Module</span> <span class="org-comment-delimiter"># </span><span class="org-comment">also includes classes</span>
          methods.concat(method_or_module.instance_methods(include_ancestors))
        <span class="org-keyword">when</span> <span class="org-type">Array</span>
          methods.concat(method_or_module)
        <span class="org-keyword">else</span>
          <span class="org-keyword">raise</span> <span class="org-type">ArgumentError</span>, <span class="org-string">"Bad argument: </span><span class="org-variable-name">#{method_or_module.inspect}</span><span class="org-string">"</span>
        <span class="org-keyword">end</span>
      }
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.clothe</span>(other)
    other.extend(<span class="org-type">Macros</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.included</span>(other)
    clothe(other)
    other.singleton_class.extend(<span class="org-type">Macros</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.extended</span>(object)
    clothe(object.singleton_class)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
In a nutshell, <code>FigLeaf</code> enables us to selectively make public methods
inherited from other classes and modules private. The objects can
still call these methods internally, but external classes are
prevented from doing so. To get an idea of how it works, we'll go
ahead and apply it to the <code>Post</code> class.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  include <span class="org-type">FigLeaf</span>
  hide <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>, ancestors: <span class="org-variable-name">true</span>,
       <span class="org-constant">:except</span> =&gt; [<span class="org-type">Object</span>, <span class="org-constant">:init_with</span>, <span class="org-constant">:new_record?</span>, 
                   <span class="org-constant">:errors</span>, <span class="org-constant">:valid?</span>, <span class="org-constant">:save</span>]
  hide_singletons <span class="org-type">ActiveRecord</span>::<span class="org-type">Calculations</span>, 
                  <span class="org-type">ActiveRecord</span>::<span class="org-type">FinderMethods</span>,
                  <span class="org-type">ActiveRecord</span>::<span class="org-type">Relation</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
In this code, we hide the entire <code>ActiveRecord::Base</code> interface, with
just a few carefully chosen exceptions like <code>#valid?</code> and <code>#save</code>. We
also hide a bunch of the more common class-level methods that
ActiveRecord adds, like <code>.find</code>, <code>.all</code>, and <code>#count</code> by calling
<code>#hide_singleton</code> with the modules which define those methods.
</p>
<p>
Now, if we jump into the console and try to call common ActiveRecord
methods on it, we are denied access:
</p>



<pre class="example">ruby-1.9.2-p0 &gt; Post.find(1)
NoMethodError: private method `find' called for #&lt;Class:0xa1a4a50&gt;
</pre>




<pre class="example">ruby-1.9.2-p0 &gt; Post.new.destroy
NoMethodError: Attempt to call private method
</pre>



<p>
We've explicitly exposed the <code>valid?</code> and <code>#errors</code> methods. Those are
methods which we exercise in our specs, so they are part of the public
contract of <code>Post</code>. We've also decided to expose <code>#save</code> as-is.
</p>
<p>
We still have a some test failures as a result of introducing
<code>FigLeaf</code>. Our <code>blog_integration_spec.rb</code> is now failing because <code>Blog</code>
tries to use <code>Post.all</code> to fetch blog entries.
</p>



<pre class="example">app/models/blog.rb:5:in `public_method': 
  method `all' for class `Class' is private (NameError)
</pre>



<p>
We hesitate to expose <code>Post.all</code>. <code>#all</code> is another "infinite
protocol" method; exposing it as part of our class interface is making
quite a large promise to our collaborators. Instead, we decide to
expose a named scope which gives <code>Blog</code> exactly what it needs, and no
more.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.most_recent</span>(limit=10)
    all(order: <span class="org-string">"pubdate DESC"</span>, limit: limit)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
We then change <code>Blog</code> to use this scope when fetching entries.
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(entry_fetcher=<span class="org-type">Post</span>.public_method(<span class="org-constant">:most_recent</span>))
  <span class="org-variable-name">@entry_fetcher</span> = entry_fetcher
<span class="org-keyword">end</span>
</pre>




<p>
The sorting and limiting code in <code>Blog</code> is now redundant:
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">entries</span>
  fetch_entries.sort_by{|e| e.pubdate}.reverse.take(10)
<span class="org-keyword">end</span>
</pre>




<p>
We remove it, confident that our integration tests will let us know if
the change breaks the intended semantics of the method.
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">entries</span>
  fetch_entries
<span class="org-keyword">end</span>
</pre>




<p>
All our tests are once again passing. And we now have an extra bulwark
against tight coupling to ActiveRecord APIs.
</p>
<p>
Let me be very clear: I'm not trying to introduce Java-like bondage &amp;
discipline back into a dynamic language. <code>FigLeaf</code> is not intended as
a hammer to keep your coworkers or your library clients in line. It's
not as if that would work, anyway; the strictures that it adds are
easy enough to circumvent.
</p>
<p>
<code>FigLeaf</code>'s intended role is more along the lines of the "rumble
strips" along highways which give you a jolt when you veer off into
the shoulder. It provides a sharp reminder when you've unthinkingly
introduced a new bit of coupling to an interface you are trying to keep
isolated from the rest of the codebase. Then, you can consciously make
the decision whether to make that method public, or find a different
way of going about what you were doing.
</p></div>

</div>

<div id="outline-container-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> Adding tags </h2>
<div class="outline-text-2" id="text-16">

<p>  Now let's add the ability to annotate posts with tags.
</p>
<p>
  What sort of functionality does tagging entail? Let's describe some
  basic use cases:
</p>
<dl>
<dt>Tagging a post</dt><dd>
<p>
     Before saving a new post, the user types some keywords into a
     "tags" field. They might separate the keywords with either spaces,
     commas, or other non-word characters. They might accidentally enter
     a tag twice. When the post is saved, it is displayed with its list
     of tags. The displayed tags are separated by commas, and have had
     any duplicates removed.
</p></dd>
<dt>Seeing a list of all tags</dt><dd>
<p>
     A visitor to the blog sees a list of all unique tags that have been
     applied to any post in the blog sidebar.
</p></dd>
<dt>Filtering by tag</dt><dd>
<p>
     When a visitor clicks on one of the tags, he or she sees a
     "filtered" view of the blog showing only posts which have been
     tagged with that keyword.
</p></dd>
</dl>


<p>
  There are plenty of other ways to use tags, but this is enough to
  get us started.
</p>
</div>

</div>

<div id="outline-container-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> An Object Model for Tags </h2>
<div class="outline-text-2" id="text-17">

<p>   Looking at the list of use cases, it seems clear that we'll need
   some kind of object that represents a list of tags. Let's start
   with that.
</p>



<pre class="src src-ruby">describe <span class="org-type">TagList</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
   The most basic behavior we can specify is how the <code>TagList</code> will
   behave with no tags in it.
</p>



<pre class="src src-ruby">describe <span class="org-string">"given a blank string"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">""</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"is empty"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.must_be_empty
  <span class="org-keyword">end</span>

  it <span class="org-string">"stringifies to the empty string"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_s.must_equal <span class="org-string">""</span>
  <span class="org-keyword">end</span>

  it <span class="org-string">"arrayifies to the empty array"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_a.must_equal []
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
   <code>TagList</code> should assist us in converting from the space- or
   comma-separated strings that users type in.
</p>



<pre class="src src-ruby">describe <span class="org-string">"given tags separated by commas or whitespace"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span> 
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">"barley, hops water, yeast"</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"is not empty"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.wont_be_empty
  <span class="org-keyword">end</span>

  it <span class="org-string">"stringifies to a comma separated list"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_s.must_equal <span class="org-string">"barley, hops, water, yeast"</span>
  <span class="org-keyword">end</span>

  it <span class="org-string">"arrayifies to a list of strings"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_a.must_equal %w[barley hops water yeast]
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
   It should also eliminate any duplicates.
</p>



<pre class="src src-ruby">describe <span class="org-string">"given duplicate tags"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span> 
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">"barley, hops, barley"</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"eliminates duplicates"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_a.must_equal %w(barley hops)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
   It should normalize the tags to lowercase.
</p>



<pre class="src src-ruby">describe <span class="org-string">"given mixed-case tags"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span> 
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">"Barley, hOps, YEAST"</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"lowercases the tags"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_a.must_equal %w(barley hops yeast)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
   It shouldn't be tripped up by being instantiated with <code>nil</code>.
</p>



<pre class="src src-ruby">describe <span class="org-string">"given nil"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span> 
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-variable-name">nil</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"is empty"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.must_be_empty
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
   We'll need to be able to combine tag lists together if we're going
   to show an overview of all tags in use on the blog.
</p>



<pre class="src src-ruby">describe <span class="org-string">"#+"</span> <span class="org-keyword">do</span>
  it <span class="org-string">"combines tag lists into one"</span> <span class="org-keyword">do</span>
    result = <span class="org-type">TagList</span>.new(<span class="org-string">"foo, bar"</span>) + <span class="org-type">TagList</span>.new(<span class="org-string">"baz, buz"</span>)
    result.must_equal(<span class="org-type">TagList</span>.new(<span class="org-string">"foo, bar, baz, buz"</span>))
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
   That tag overview should probably be in alphabetical order, so
   we'll want the tag list to be able to return a sorted version of
   itself.
</p>



<pre class="src src-ruby">describe <span class="org-string">"#alphabetical"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">"foo, bar, baz, fuz"</span>)
    <span class="org-variable-name">@result</span> = <span class="org-variable-name">@it</span>.alphabetical
  <span class="org-keyword">end</span>

  it <span class="org-string">"returns the tags in alpha order"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@result</span>.to_a.must_equal %w(bar baz foo fuz)
  <span class="org-keyword">end</span>

  it <span class="org-string">"returns another tag list"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@result</span>.must_be_kind_of <span class="org-type">TagList</span>
    <span class="org-variable-name">@result</span>.wont_be_same_as <span class="org-variable-name">@it</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
   Finally, we'll specify a handy conversion method to quickly turn
   things that aren't tag lists into tag lists.
</p>



<pre class="src src-ruby">describe <span class="org-string">"TagList()"</span> <span class="org-keyword">do</span>
  describe <span class="org-string">"given a TagList"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"returns the same tag list"</span> <span class="org-keyword">do</span>
      list = <span class="org-type">TagList</span>.new(<span class="org-string">""</span>)
      <span class="org-type">TagList</span>(list).must_be_same_as(list)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  describe <span class="org-string">"given an array"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>(%w[foo bar])
    <span class="org-keyword">end</span>
    it <span class="org-string">"returns a tag list"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.must_be_kind_of(<span class="org-type">TagList</span>)
    <span class="org-keyword">end</span>

    it <span class="org-string">"contains the given tags"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.to_a.must_equal(%w[foo bar])
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
   The converter has a similar look and feel to Ruby's built-in
   conversion methods such as <code>String</code>, <code>Array</code>, and <code>Integer</code>.
</p>
<p>
   Implementing these requirements takes considerably less space than
   we needed to spec them out:
</p>



<pre class="src src-ruby">require <span class="org-string">'forwardable'</span>

<span class="org-keyword">module</span> <span class="org-type">Conversions</span>
  <span class="org-keyword">private</span>
  <span class="org-keyword">def</span> <span class="org-function-name">TagList</span>(value)
    <span class="org-keyword">return</span> value <span class="org-keyword">if</span> value.is_a?(<span class="org-type">TagList</span>)
    <span class="org-type">TagList</span>.new(value)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-keyword">class</span> <span class="org-type">TagList</span>
  extend <span class="org-type">Forwardable</span>
  include <span class="org-type">Enumerable</span>
  attr_reader <span class="org-constant">:tags</span>

  def_delegators <span class="org-constant">:tags</span>, <span class="org-constant">:empty?</span>, <span class="org-constant">:to_a</span>, <span class="org-constant">:each</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(tags)
    <span class="org-keyword">case</span> tags
    <span class="org-keyword">when</span> <span class="org-type">Array</span>
      <span class="org-variable-name">@tags</span> = tags
    <span class="org-keyword">else</span>
      <span class="org-variable-name">@tags</span> = tags.to_s.split(<span class="org-string">/\W+/</span>)
    <span class="org-keyword">end</span>
    <span class="org-variable-name">@tags</span>.uniq!
    <span class="org-variable-name">@tags</span>.each(&amp;<span class="org-constant">:downcase!</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">to_s</span>
    tags.join(<span class="org-string">", "</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">to_ary</span>
    <span class="org-variable-name">@tags</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">+</span>(other)
    <span class="org-variable-name">self</span>.class.new(to_a + other.to_a)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">==</span>(other)
    to_a == <span class="org-type">Array</span>(other)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">alphabetical</span>
    <span class="org-variable-name">self</span>.class.new(tags.sort)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
   Our <code>TagList</code> implementation behaves much like an Array, and in
   fact it is built on top of an internal Array called <code>@tags</code> which
   holds the actual tag strings. Some of its Array-style methods, like
   <code>empty?</code> and <code>:each</code>, don't need any special treatment, so
   <code>TagList</code> passes them straight on to the underlying <code>Array</code> using
   the <code>Forwardable</code> library. Other methods have more tag-specific
   behavior, and are explicitly implemented.
</p>
</div>

</div>

<div id="outline-container-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> Attaching the <code>TagList</code> to a <code>Post</code> </h2>
<div class="outline-text-2" id="text-18">


<p>
   Now how do we attach our tag list class to a <code>Post</code> object? We'll
   start out with a naive solution which just serializes the tags to a
   column in the <code>posts</code> table. In order to do that, we create a
   migration for a new <code>tags</code> column.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">AddTagsToPosts</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Migration</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.up</span>
    add_column <span class="org-constant">:posts</span>, <span class="org-constant">:tags</span>, <span class="org-constant">:string</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.down</span>
    remove_column <span class="org-constant">:posts</span>, <span class="org-constant">:tags</span>, <span class="org-constant">:string</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
   Now we need to tell <code>Post</code> to represent its new <code>tags</code> attribute as
   as a <code>TagList</code> instead of as a raw string. We do that using ActiveRecord's
   <a href="http://api.rubyonrails.org/classes/ActiveRecord/Aggregations/ClassMethods.html">composed<sub>of</sub></a> facility:
</p>



<pre class="src src-ruby">composed_of <span class="org-constant">:tags</span>, <span class="org-constant">:class_name</span> =&gt; <span class="org-string">'TagList'</span>, mapping: %w(tags tags),
                   <span class="org-constant">:converter</span>  =&gt; -&gt;(value) { <span class="org-type">TagList</span>(value) }
</pre>




<p>
   This incantation tells ActiveRecord to mediate access to the
   <code>tags</code> attribute using a <code>TagList</code>. When a new <code>Post</code> is created,
   ActiveRecord will initialize a <code>TagList</code> object, passing it the raw <code>tags</code>
   data. When it comes time to write the record back to the database,
   ActiveRecord will use the <code>TagList</code>'s own <code>tags</code> attribute as the new value
   of the <code>tags</code> field. Recall that in <code>TagList</code>, <code>#tags</code> is an
   accessor to the underlying Array instance.
</p>
<p>
   The <code>:converter</code> option tells ActiveRecord what do do when some code calls
   <code>post.tags=</code> with a new value. In this case, it will convert the
   given value into a <code>TagList</code>.
</p>
<p>
   <code>TagList</code> represents itself internally using an array, but the
   <code>tags</code> column we just created is a simple string field. In order to
   safely write an array into a string field and get it out again as
   an array, we need to tell ActiveRecord to serialize the field:
</p>



<pre class="src src-ruby">serialize <span class="org-constant">:tags</span>
</pre>




<p>
   Now whenever the <code>tags</code> field is written to the database, the value
   (an array provided by <code>TagList</code>) will first be serialized into YAML
   format. When it is read out again, it will be parsed from the YAML
   back into an array, and the array will be fed back into a new
   <code>TagList</code>.
</p>
<p>
   We could have serialized the <code>TagList</code> object itself to the <code>tags</code>
   column. But serializing application objects to YAML can lead to
   headaches down the road. We have to ensure that the <code>TagList</code> code
   is loaded before accessing that field, something that can be
   surprisingly tricky when running in development mode with Rails'
   class autoloading enabled. And if we ever changed the
   representation of <code>TagList</code>, we'd could find ourselves in
   versioning hell as we try to load <code>TagList</code> objects which were
   serialized before the change. It's all-around easier to only
   serialize Ruby built-ins like Arrays and Hashes.
</p>
</div>

</div>

<div id="outline-container-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> Making <code>Post</code> more tag-aware </h2>
<div class="outline-text-2" id="text-19">


<p>
   Now we can attach tags to an individual post, but we also need to
   be able to get a list of all the tags in use, and to find all posts
   with a given tag. In order to drive out this functionality, we
   create a new integration spec suite for the <code>Post</code> class, to
   complement its existing unit-level spec suite.
</p>



<pre class="src src-ruby">describe <span class="org-type">Post</span> <span class="org-keyword">do</span>
  include <span class="org-type">SpecHelpers</span>
  before <span class="org-keyword">do</span>
    setup_database
    <span class="org-variable-name">@blog</span> = <span class="org-type">Blog</span>.new
  <span class="org-keyword">end</span>

  after <span class="org-keyword">do</span>
    teardown_database
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">make_post</span>(attrs)
    attrs[<span class="org-constant">:title</span>] ||= <span class="org-string">"Post </span><span class="org-variable-name">#{attrs.hash}</span><span class="org-string">"</span>
    post = <span class="org-variable-name">@blog</span>.new_post(attrs)
    post.publish.must_equal(<span class="org-variable-name">true</span>)
    post
  <span class="org-keyword">end</span>

  describe <span class="org-string">".all_tags_alphabetical"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@post_tags</span> = [
                    <span class="org-variable-name">nil</span>,        <span class="org-comment-delimiter"># </span><span class="org-comment">make sure nils are handled</span>
                    %w(barley yeast),
                    %w(yeast hops),
                    %w(water)
                   ]
      <span class="org-variable-name">@post_tags</span>.each <span class="org-keyword">do</span> |tags|
        make_post(title: tags.inspect, tags: tags)
      <span class="org-keyword">end</span>
      <span class="org-variable-name">@it</span> = <span class="org-type">Post</span>.all_tags_alphabetical
    <span class="org-keyword">end</span>

    it <span class="org-string">"returns a unique, alphabetized list of all tags"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.must_equal <span class="org-type">TagList</span>(%w(barley hops water yeast))
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  describe <span class="org-string">".tagged"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"filters the collection by tag"</span> <span class="org-keyword">do</span>
      duck  = make_post tags: %w[billed feathered]
      robin = make_post tags: %w[reddish feathered]
      fox   = make_post tags: %w[reddish furred]
      platypus = make_post tags: %w[billed furred]

      reddish = <span class="org-type">Post</span>.tagged(<span class="org-string">"reddish"</span>)
      reddish.size.must_equal 2
      reddish.must_include(robin)
      reddish.must_include(fox)

      furred = <span class="org-type">Post</span>.tagged(<span class="org-string">"furred"</span>)
      furred.size.must_equal 2
      furred.must_include(fox)
      furred.must_include(platypus)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
These new specs are satisfied with a trio of new class-level methods
on <code>Post</code>:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.most_recent</span>(limit=10)
    order(<span class="org-string">"pubdate DESC"</span>).limit(limit)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.all_tags_alphabetical</span>
    all_tags.alphabetical
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.all_tags</span>
    except(<span class="org-constant">:limit</span>).map(&amp;<span class="org-constant">:tags</span>).reduce(<span class="org-type">TagList</span>.new([]), &amp;<span class="org-constant">:+</span>)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
That last method is worth a second look. Remember that we defined the
<code>+</code> operator on <code>TagList</code> to combine two tag lists into one. That
comes in handy now, as we are able to use <code>#reduce</code> to very succinctly
combine an arbitrary number of tag lists into one master list.
</p>
</div>

</div>

<div id="outline-container-20" class="outline-2">
<h2 id="sec-20"><span class="section-number-2">20</span> Accepting and displaying tags </h2>
<div class="outline-text-2" id="text-20">


<p>
In order to add tags to posts we need a place to enter them. We add a
new field to the "new post" form:
</p>



<pre class="src src-html">&lt;%= label :tags, <span class="org-string">"Tags:"</span> %&gt;
&lt;%= f.text_field :tags %&gt;
</pre>




<p>
We also update the blog entry partial to display any tags that are
associated with a blog post.
</p>



<pre class="src src-html">&lt;<span class="org-function-name">p</span> <span class="org-variable-name">class</span>=<span class="org-string">"entry_tags"</span>&gt;Tags: 
  &lt;<span class="org-function-name">span</span> <span class="org-variable-name">class</span>=<span class="org-string">"tags"</span>&gt;&lt;%= entry.tags %&gt;&lt;/<span class="org-function-name">span</span>&gt;
&lt;/<span class="org-function-name">p</span>&gt;
</pre>




<p>
Remember that <code>entry.tags</code> will return a <code>TagList</code>, and <code>TagList.to_s</code>
is defined to format the tags separated by commas. So this should look
fine when rendered.
</p>
<p>
We also want to show a top-level list of tags that shows all tags in
use on the blog. We add a new section to the sidebar in the main
application layout:
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">h4</span>&gt;<span class="org-underline">Tags</span>&lt;/<span class="org-function-name">h4</span>&gt;
&lt;<span class="org-function-name">nav</span>&gt;
  &lt;<span class="org-function-name">ul</span>&gt;
    &lt;%= render partial: <span class="org-string">"/tags/tag_item"</span>,
               collection: @blog.tags %&gt;
  &lt;/<span class="org-function-name">ul</span>&gt;
&lt;/<span class="org-function-name">nav</span>&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
</pre>




<p>
The <code>tags/tag_item</code> partial is just a thin wrapper around the <code>tags/tag</code>
partial:
</p>



<pre class="src src-html">&lt;<span class="org-function-name">li</span>&gt;&lt;%= render partial: <span class="org-string">"/tags/tag"</span>, object: tag_item %&gt;&lt;/<span class="org-function-name">li</span>&gt;
</pre>




<p>
The <code>tags/tag</code> partial renders a link to a tag-filtered view of the
blog:
</p>



<pre class="src src-html">&lt;%= link_to tag.to_s, root_path(:tag =&gt; tag.to_s) %&gt;
</pre>




<p>
To make this work, we make a small addition to the <code>BlogController</code>.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">BlogController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-keyword">def</span> <span class="org-function-name">index</span>
    <span class="org-keyword">if</span> params[<span class="org-constant">:tag</span>].present?
      <span class="org-variable-name">@blog</span> = <span class="org-variable-name">@blog</span>.filter_by_tag(params[<span class="org-constant">:tag</span>])
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
If a <code>:tag</code> parameter is supplied to the index action, it puts a
filtered version of the blog into <code>@blog</code>. We define
<code>Blog#filter_by_tag</code> as follows:
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">filter_by_tag</span>(tag)
  <span class="org-type">FilteredBlog</span>.new(<span class="org-variable-name">self</span>, tag)
<span class="org-keyword">end</span>
</pre>




<p>
Then we define <code>FilteredBlog</code> as a decorator which wraps the
main <code>Blog</code> instance and filters its <code>#entries</code> by a given tag.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">class</span> <span class="org-type">FilteredBlog</span> &lt; <span class="org-type">DelegateClass</span>(<span class="org-type">Blog</span>)
    include ::<span class="org-type">Conversions</span>

    <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(blog, tag)
      <span class="org-keyword">super</span>(blog)
      <span class="org-variable-name">@tag</span> = tag
    <span class="org-keyword">end</span>

    <span class="org-keyword">def</span> <span class="org-function-name">entries</span>
      <span class="org-type">Taggable</span>(<span class="org-keyword">super</span>).tagged(<span class="org-variable-name">@tag</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
This class is an implementation detail of <code>Blog</code>, and will not be used
by any other code, so we just nest it inside the <code>Blog</code> class rather
than giving it its own file.
</p>
<p>
Wondering about the <code>DelegateClass(Blog)</code> bit? That's a very close
relative to <code>SimpleDelegator</code>, which we've already
used. <code>SimpleDelegator</code> is a generic delegator base class which can
work when wrapped around any underlying
object. <code>DelegateClass(klass)</code>, on the other hand, generates a
delegator base class customized specifically for wrapping objects of
the passed <code>klass</code>. In practice, it doesn't make a huge difference;
but delegates based on <code>DelegateClass</code> may be a little more efficient
since they don't have to use <code>#method_missing</code> to intercept method
calls. There are some other minor differences; for instance, the class
<code>DelegateClass()</code> generates responds to <code>.public_instance_methods</code>
with a more accurate list than the <code>SimpleDelegator</code> version. Since we
know that <code>FilteredBlog</code> will always be wrapping a <code>Blog</code> object, we can
use <code>DelegateClass()</code> instead of <code>SimpleDelegator</code>.
</p>
<p>
At this point, we have a bare-bones but still useful post-tagging
functionality. We can add tags to a post, see the keywords a post has
been tagged with, and see a list of all tags on the front page. And
when we click on one of the tags, we are presented with a subset of
posts which are tagged with that keyword.
</p>
<p>
<img src="./images/tags.png"  alt="./images/tags.png" />
</p>
</div>

</div>

<div id="outline-container-21" class="outline-2">
<h2 id="sec-21"><span class="section-number-2">21</span> Extracting a Taggable role </h2>
<div class="outline-text-2" id="text-21">


<p>
<code>:composed_of</code> enabled us to keep most of the tagging code inside of
<code>TagList</code> and out of <code>Post</code>. But there is still a fair amount of
tagging-specific code in the <code>Post</code> class. This is troubling for two
reasons:
</p>
<ol>
<li>Right now it's just tagging. But what about when we add other
   functionality, like post revision control, or authorization? Will
   every new feature that we add result in adding another dozen lines
   of code to <code>Post</code>? What ever happened to the Single Responsibility
   Principle?
</li>
<li>What if we decide we want to tag entities other than posts? Will we
   be duplicating this code for every class that can be tagged?
</li>
</ol>


<p>
We might try to pull the tagging "facet" into a module. For each new
feature, we could include a new module in <code>Post</code>:
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  include <span class="org-type">Taggable</span>
  include <span class="org-type">RevisionControlled</span>
  include <span class="org-type">Permissible</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">etc...</span>
<span class="org-keyword">end</span>
</pre>




<p>
And in fact, this is how many Rails projects address the issue of
ever-expanding class files. But does this really address the root
problem? We're still adding more and more responsibilities to <code>Post</code>
objects. The only difference is, now it's harder to find the
definition of any given <code>Post</code> method (or validation, or
before-filter&hellip;) beause it might be in any of a half-dozen different
files.
</p>
<p>
Instead of using modules, let's see if we can extract out the
"taggable" responsibility in a way that keeps it as orthogonal as
possible to the item being tagged.
</p>
<p>
We'll start by defining a <code>TaggableRecord</code> mixin module. This module
will represent the taggable "role" that a model object may
assume. When injected into an object using <code>Object#extend</code>, this
module will intercept the <code>#tags</code> and <code>#tags=</code> methods.
</p>



<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">TaggableRecord</span>
  <span class="org-keyword">def</span> <span class="org-function-name">tags</span>
    _tag_list
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">tags=</span>(new_tags)
    <span class="org-variable-name">@_tag_list</span> = <span class="org-type">TagList</span>.new(new_tags)
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
This module will also intercept calls to <code>#save</code>. Before calling the
object's original <code>#save</code> method, <code>TaggableRecord</code> updates's the
object's <code>tags</code> field. It uses the ActiveRecord-provided <code>#[]=</code> method
to write the new <code>tags</code> value so as to avoid calling the
<code>TaggableRecord#tags=</code> method.
</p>



<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">TaggableRecord</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">save</span>(*args, &amp;block)
    <span class="org-variable-name">self</span>[<span class="org-constant">:tags</span>] = _tag_list.to_a
    <span class="org-keyword">super</span>
  <span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
<code>TaggableRecord</code> also uses the ActiveRecord-provided <code>#[]</code> to
initially load up its <code>TagList</code> with values from the original record.
</p>



<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">TaggableRecord</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">private</span>

  <span class="org-keyword">def</span> <span class="org-function-name">_tag_list</span>
    <span class="org-variable-name">@_tag_list</span> ||= <span class="org-type">TagList</span>.new(<span class="org-variable-name">self</span>[<span class="org-constant">:tags</span>])
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
Since this module will be included into objects which already have
their own state and methods, we prefix our private instance variable
and method names with an underscore to make naming collisions less
likely.
</p>
<p>
Since up until now we've used external decorators
(e.g. <code>SimpleDelegator</code>) to adorn objects with new functionality, you
may be wondering why we're using a module now. In this case, we need
the tight integration that only a module can give us. For instance, by
intercepting <code>#save</code> within the object, rather than in an outside
wrapper, we also implicitly intercept any other methods which use
<code>#save</code>&mdash;such as <code>#create</code>. In this case, that's exactly the behavior
we want.
</p>
<p>
That takes care of the instance-level functionality; but a lot of the
tagging-related code on <code>Post</code> is at the class level. We define a
module for that next:
</p>



<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">TaggableRelation</span>
  <span class="org-keyword">def</span> <span class="org-function-name">all_tags_alphabetical</span>
    all_tags.alphabetical
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">all_tags</span>
    except(<span class="org-constant">:limit</span>).map{|e| <span class="org-type">Taggable</span>(e).tags}.reduce(<span class="org-type">TagList</span>.new([]), &amp;<span class="org-constant">:+</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">tagged</span>(tag)
    select{|e| <span class="org-type">Taggable</span>(e).tags.include?(tag)}
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
These are pretty much exactly as they were in <code>Post</code>.
</p>
<p>
As we decided earlier, we don't want to have <code>Post</code> always carrying
this tagging baggage even when it isn't needed. We need a way to
quickly apply the taggable "hat" to objects on a just-in-time
basis. For that we define another global conversion method:
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">Taggable</span>(item)
  <span class="org-keyword">case</span> item
  <span class="org-keyword">when</span> ::<span class="org-type">Class</span>, ::<span class="org-type">ActiveRecord</span>::<span class="org-type">Relation</span>
    item.extend(::<span class="org-type">TaggableRelation</span>)
  <span class="org-keyword">else</span> 
    item.extend(::<span class="org-type">TaggableRecord</span>)  
  <span class="org-keyword">end</span>
  item.extend(::<span class="org-type">Taggable</span>)
<span class="org-keyword">end</span>
</pre>




<p>
This conversion method lets us apply tagging functionality to record
instances, relations, and classes by simply calling
<code>Taggable(object_to_be_made_taggable)</code>.
</p>
<p>
We are now able to remove a bunch of code from <code>Post</code>:
</p>



<pre class="src src-ruby">composed_of <span class="org-constant">:tags</span>, <span class="org-constant">:class_name</span> =&gt; <span class="org-string">'TagList'</span>, mapping: %w(tags tags),
                   <span class="org-constant">:converter</span>  =&gt; -&gt;(value) { <span class="org-type">TagList</span>(value) }
serialize <span class="org-constant">:tags</span>

<span class="org-keyword">def</span> <span class="org-function-name">self.all_tags_alphabetical</span>
  all_tags.alphabetical
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">self.all_tags</span>
  except(<span class="org-constant">:limit</span>).map(&amp;<span class="org-constant">:tags</span>).reduce(<span class="org-type">TagList</span>.new([]), &amp;<span class="org-constant">:+</span>)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">self.tagged</span>(tag)
  select{|e| e.tags.include?(tag)}
<span class="org-keyword">end</span>
</pre>




<p>
In fact, the only tagging-related code we can't get rid of is the line
that tells ActiveRecord to serialize the <code>tags</code> field:
</p>



<pre class="src src-ruby">serialize <span class="org-constant">:tags</span>
</pre>




<p>
Now we walk through the codebase, applying the <code>Taggable()</code> role
anywhere we need to treat a <code>Post</code> or a collection of posts as
taggable objects. For instance, in the <code>_entry</code> partial we apply it
before rendering the tag list:
</p>



<pre class="src src-html">&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">p</span>&gt;&lt;<span class="org-function-name">time</span> <span class="org-variable-name">pubdate</span>=<span class="org-string">"pubdate"</span>&gt;&lt;%= entry.pubdate %&gt;&lt;/<span class="org-function-name">time</span>&gt;&lt;/<span class="org-function-name">p</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= entry.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
    &lt;<span class="org-function-name">p</span> <span class="org-variable-name">class</span>=<span class="org-string">"entry_tags"</span>&gt;Tags: 
      &lt;<span class="org-function-name">span</span> <span class="org-variable-name">class</span>=<span class="org-string">"tags"</span>&gt;&lt;%= Taggable(entry).tags %&gt;&lt;/<span class="org-function-name">span</span>&gt;
    &lt;/<span class="org-function-name">p</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;%= entry.render_body %&gt;
&lt;/<span class="org-function-name">article</span>&gt;
</pre>




<p>
And in the <code>PostsController</code> we apply it to a post which is about to
be saved, so that any <code>tags</code> which were written to the new post are
correctly serialized.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">create</span>
  <span class="org-variable-name">@post</span> = <span class="org-type">Taggable</span>(<span class="org-variable-name">@blog</span>.new_post(params[<span class="org-constant">:post</span>]))
  <span class="org-keyword">if</span> <span class="org-variable-name">@post</span>.publish
    redirect_to root_path, notice: <span class="org-string">"Post added!"</span>
  <span class="org-keyword">else</span>
    render <span class="org-string">"new"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Note that in wherever we use <code>Taggable()</code>, we use its return value as
the "taggable" entity. We do this even know we know that <code>Taggable()</code>
extends its argument with a module, altering it in place. We could just as
well do this:
</p>



<pre class="src src-ruby"><span class="org-type">Taggable</span>(some_object)
some_object.tags = <span class="org-string">"foo, bar"</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Why use the return value? We do it for consistency and implementation
hiding. We happen to know (because we just wrote it) that <code>Taggable()</code>
actually modifies its argument in place. But in other cases, we wrote
conversion methods which don't modify their argument; instead, they
return a wrapped object or a brand new object.
</p>
<p>
By consistently using the return value of conversion methods
throughout our codebase&mdash;whether we need to or not&mdash;we free
ourselves from the mental burden of having to remember how a
particular conversion works. Not only that, but we future-proof our
code this way: if, at some point, we decide we <em>do</em> want to use a
decorator instead of a module, we can alter the implementation of
<code>Taggable()</code> know that it will continue to work wherever we've used
it.
</p>

</div>

</div>

<div id="outline-container-22" class="outline-2">
<h2 id="sec-22"><span class="section-number-2">22</span> Refactoring to a separate ActiveRecord model </h2>
<div class="outline-text-2" id="text-22">

<p>  We don't have to spend much time with our new tagging system to
  realize that our naive implementation is grossly inefficient at
  scale. To search across or list all tags in the blog, we are forced
  to load every single blog entry. If this blog engine is going to
  compete with WordPress it's definitely going to need a faster tags
  implementation.
</p>
<p>
  We decide to give tags some database tables of their own. In order
  to keep tags nice and generic, we'll create a <code>tags</code> table which
  stores the actual tag keyword, and an <code>item_tags</code> table which will
  polymorphically map from tags to taggable items (such as posts).
</p>
<p>
  We write a migration that creates the new tables, migrates the old
  tags data to the new tables, and then removes the <code>tags</code> field from
  the <code>posts</code> table.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">AddTagTables</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Migration</span>

  <span class="org-keyword">class</span> <span class="org-type">Post</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>; <span class="org-keyword">end</span>
  <span class="org-keyword">class</span> <span class="org-type">Tag</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>; <span class="org-keyword">end</span>
  <span class="org-keyword">class</span> <span class="org-type">ItemTag</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
    belongs_to <span class="org-constant">:tag</span>
    belongs_to <span class="org-constant">:item</span>, <span class="org-constant">:polymorphic</span> =&gt; <span class="org-variable-name">true</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.up</span>
    create_table <span class="org-constant">:tags</span> <span class="org-keyword">do</span> |t|
      t.string <span class="org-constant">:name</span>
      t.timestamps
    <span class="org-keyword">end</span>
    create_table <span class="org-constant">:item_tags</span> <span class="org-keyword">do</span> |t|
      t.integer <span class="org-constant">:item_id</span>
      t.string  <span class="org-constant">:item_type</span>
      t.integer <span class="org-constant">:tag_id</span>
    <span class="org-keyword">end</span>
    <span class="org-type">Post</span>.find_each <span class="org-keyword">do</span> |post|
      <span class="org-type">Array</span>(post.tags).each <span class="org-keyword">do</span> |tag|
        tag_record = <span class="org-type">Tag</span>.create!(<span class="org-constant">:name</span> =&gt; tag.to_s)
        <span class="org-type">ItemTag</span>.create!(<span class="org-constant">:item</span> =&gt; post, <span class="org-constant">:tag</span> =&gt; tag_record)
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
    remove_column <span class="org-constant">:posts</span>, <span class="org-constant">:tags</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.down</span>
    <span class="org-keyword">raise</span> <span class="org-type">ActiveRecord</span>::<span class="org-type">IrreversibleMigration</span>, <span class="org-string">"Cannot be reversed"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
Note that we define any ActiveRecord models we need for the data migration within
the context of the migration. This will enable the migration to
continue working even if we change or remove those models in future
revisions.
</p>
<p>
Our new tables are strictly implementation details; we still intend to
work with tags in terms of our tried-and-true <code>TagList</code> class. We
define some bare-bones ActiveRecord models for the new tables, with
no business logic and just enough code to set up their
relationships. In order to underscore the fact that these are not
full-fledged business models, we put the files in a new directory
called <code>app/data</code>.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/data/tag.rb</span>
<span class="org-keyword">class</span> <span class="org-type">Tag</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  has_many <span class="org-constant">:item_tags</span>
<span class="org-keyword">end</span>
</pre>






<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/data/tag.rb</span>
<span class="org-keyword">class</span> <span class="org-type">ItemTag</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  belongs_to <span class="org-constant">:tag</span>
  belongs_to <span class="org-constant">:item</span>, <span class="org-constant">:polymorphic</span> =&gt; <span class="org-variable-name">true</span>
  delegate <span class="org-constant">:name</span>, to: <span class="org-constant">:tag</span>
<span class="org-keyword">end</span>
</pre>




<p>
While technically ActiveRecord classes, we'll use these classes more
like <a href="http://martinfowler.com/eaaCatalog/rowDataGateway.html">Row Data Gateways</a> - thin wrappers around a row of data.
</p>
<p>
Before we forget, we remove the one remaining vestige of "tagginess"
from <code>Post</code>:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
serialize <span class="org-constant">:tags</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Now <code>Post</code> contains no tag-related code whatsoever.
</p>
<p>
Currently, our <code>TaggableRecord</code> role module uses a record's
<code>#[]=/=#[]=</code> methods to write tags into the record. That won't do
anymore. We rewrite <code>TaggableRecord</code> to talk to use a "tag storage"
object for reading and writing tags instead.
</p>



<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">TaggableRecord</span>
  attr_accessor <span class="org-constant">:_tag_storage</span>

  <span class="org-keyword">def</span> <span class="org-function-name">tags</span>
    <span class="org-variable-name">@_tag_list</span> ||= <span class="org-type">TagList</span>.new(_tag_storage.load)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">tags=</span>(new_tags)
    <span class="org-variable-name">@_tag_list</span> = <span class="org-type">TagList</span>.new(new_tags)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">save</span>(*args, &amp;block)
    <span class="org-keyword">super</span>.tap <span class="org-keyword">do</span> |successful|
      <span class="org-keyword">if</span> successful
        _tag_storage.store(tags.to_a)
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>





<p>
What's a tag storage object? Defining it is our next job. From our
definition in <code>TaggableRecord</code>, we know it needs to respond to two
methods: <code>#load</code> and <code>#store</code>.
</p>
<p>
First of all, it will keep a reference to the item which it is storing
tags for.
</p>



<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">TagStorage</span>
  attr_reader <span class="org-constant">:item</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(item)
    <span class="org-variable-name">@item</span> = item
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
</pre>




<p>
Loading tags will map across an <code>ItemTag</code> collection to get the names
of all the tags applied to the item.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">load</span>
  item_tags.map(&amp;<span class="org-constant">:name</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Item tags is simply a memoizing later on top of <code>#fetch_item_tags</code>:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">item_tags</span>
  <span class="org-variable-name">@item_tags</span> ||= fetch_item_tags
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
<code>#fetch_item_tags</code> is where the actual tag loading happens. We create
a scope which encompasses all <code>ItemTag</code> records which have a type and
ID corresponding to the item being tagged. We include the <code>tags</code> table
in the query, since we know we'll be needing the tag names.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">fetch_item_tags</span>
  <span class="org-type">ItemTag</span>.where(item_type: item.class, item_id: item.id).includes(<span class="org-constant">:tag</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
That takes care of loading tags. Storing tags is a little more
involved. Our <code>#store</code> method must find the difference between the
tags currently stored for the item, and the tags that have been set using
the item's <code>#tags</code> attribute. Then it must create and delete <code>ItemTag</code>
and <code>Tag</code> records accordingly.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">store</span>(tags)
  current_tags  = item_tags.map(&amp;<span class="org-constant">:name</span>)
  new_tags      = <span class="org-type">Array</span>(tags)
  remove_tags(current_tags, new_tags)
  add_tags(current_tags, new_tags)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
<code>#add_tags</code> determines which tags have been added, and creates the
needed <code>ItemTag</code> mappings:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">add_tags</span>(current_tags, new_tags)
  new_tags = new_tags - current_tags
  new_tags.each <span class="org-keyword">do</span> |tag|
    item_tags &lt;&lt; <span class="org-type">ItemTag</span>.create!(item_tag_attributes(tag))
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
It uses a helper method <code>#item_tag_attributes</code> to generate the
attributes for new <code>ItemTag</code> records:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">item_tag_attributes</span>(t)
  tag = <span class="org-type">Tag</span>.find_or_create_by_name(t)
  {item: item, tag: tag}
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Finally, <code>#remove_tags</code> goes through the cached list of item tag
mappings, and removes any that are no longer needed from both the
cached list and the database.
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">remove_tags</span>(current_tags, new_tags)
  removed_tags = current_tags - new_tags
  item_tags.each <span class="org-keyword">do</span> |item_tag|
    <span class="org-keyword">if</span> removed_tags.include?(item_tag.name)
      item_tag.delete
      item_tags.delete(item_tag)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Whew! That was a fair amount of code. But now we have a way to store
tags in the database for arbitrary objects: all we need is a type and
an id, and we can store tags against it.
</p>
<p>
Since <code>TaggableRecord</code> now needs a <code>TagStorage</code> object, we have to
update our <code>Taggable</code> conversion.
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">Taggable</span>(item, tag_storage=::<span class="org-type">TagStorage</span>.new(item))
  <span class="org-keyword">return</span> item <span class="org-keyword">if</span> item.kind_of?(::<span class="org-type">Taggable</span>)
  item.extend(::<span class="org-type">Taggable</span>)
  <span class="org-keyword">case</span> item
  <span class="org-keyword">when</span> ::<span class="org-type">Class</span>, ::<span class="org-type">ActiveRecord</span>::<span class="org-type">Relation</span>
    item.extend(::<span class="org-type">TaggableRelation</span>)
  <span class="org-keyword">else</span> 
    item.extend(::<span class="org-type">TaggableRecord</span>)
    item._tag_storage = tag_storage
  <span class="org-keyword">end</span>
  item
<span class="org-keyword">end</span>
</pre>




<p>
The <code>Taggable()</code> code reminds us: what about wrapping classes and
relations? How does that change now that we are storing tags in the
database?
</p>
<p>
The <code>#all_tags</code> accessor doesn't change much, except now it's querying
<code>ItemTag</code> instead of the current class/relation:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">all_tags</span>
  <span class="org-type">TagList</span>(<span class="org-type">ItemTag</span>.where(item_type: klass).includes(<span class="org-constant">:tag</span>).map(&amp;<span class="org-constant">:name</span>))
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>




<p>
Now that tagged items are no longer expected to have a <code>tags</code> field,
we need to wrap the underlying <code>#new</code> method in one which understands
and handles the <code>tags</code> parameter. Otherwise if we tried to create
e.g. a new <code>Post</code> with parameters which included <code>tags</code>, it would
complain that no such attribute exists.
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">new</span>(attrs={}, &amp;block)
  attrs = attrs.dup
  tags  = attrs.delete(<span class="org-constant">:tags</span>)
  <span class="org-type">Taggable</span>(<span class="org-keyword">super</span>(attrs, &amp;block)).tap <span class="org-keyword">do</span> |item|
    item.tags = tags
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>




<p>
The last <code>TaggableRelation</code> method we need to update is the one that
enables us to get a list of all items tagged with a particular
keyword. This method turns out to be a bit of a doozy.
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">tagged</span>(tag)
  joins(<span class="org-string">"JOIN item_tags ON item_tags.item_id = </span><span class="org-variable-name">#{table_name}</span><span class="org-string">.id AND "</span> \
        <span class="org-string">"item_tags.item_type = \"</span><span class="org-variable-name">#{klass.name}</span><span class="org-string">\""</span>).
    joins(<span class="org-string">"JOIN tags ON item_tags.tag_id = tags.id"</span>).
    where(<span class="org-string">"tags.name = ?"</span>, tag)
<span class="org-keyword">end</span>
</pre>




<p>
I will concede that this is a bit nuts. In trying to avoid putting any
requirements whatsoever on the tagged classes&mdash;enabling classes like
<code>Post</code> to be blissfully unaware that tagging even exists&mdash;we've been
forced to assemble a pretty gnarly query. Simply requiring classes
which may be tagged to declare a <code>has_many :through</code> relationship to
the <code>tags</code> table would have vastly simplified this.
</p>
<p>
Sometimes going "off the rails" results in pain like this. Is it worth
it? That's a decision only you and your team can make, in the context
of a given project.
</p>
<p>
We've now migrated tag storage from a per-record field to a set of
separate tables. While we wrote a fair amount of new code for this,
it's worth reflecting on what we <strong>didn't</strong> change:
</p>
<ol>
<li>We didn't change any of the views.
</li>
<li>We didn't change any of the controllers.
</li>
<li>We didn't change any of the helpers.
</li>
<li>We didn't change the Blog model.
</li>
<li>We removed one line from <code>Post</code>.
</li>
</ol>


<p>
By pulling "taggability" into a discrete role, rather than an
inherent attribute of the tagged objects, we've decoupled <em>what</em> is
tagged from <em>how</em> it is tagged. Our tagging implementation can
change independently of other concerns. If tomorrow we decided to
change to using Redis for our tag store, the change might not be
<em>small</em>, but it would be <em>isolated</em>. Most of the app wouldn't know or
care about the change. To quote Kent Beck in <span style="text-decoration:underline;">Smalltalk Best Practice Patterns</span>:
</p>
<blockquote>

<p>When you can extend a system solely by adding new objects without
modifying any existing objects, then you have a system that is
flexible and cheap to maintain.
</p>
</blockquote>


</div>

</div>

<div id="outline-container-23" class="outline-2">
<h2 id="sec-23"><span class="section-number-2">23</span> Data-Context-Interaction </h2>
<div class="outline-text-2" id="text-23">


<p>  
  If this process of factoring out roles has intrigued you, you may be
  interested in exploring the the Data-Context-Interaction (DCI)
  pattern. Here are some links to further reading
</p>
<ul>
<li>Jim Gay is writing a <a href="http://www.clean-ruby.com/">book on using DCI in Ruby and Rails</a>. I've
    seen Jim present on this topic and he's at the forefront of
    applying this approach to Rails projects. I'm eagerly looking
    forward to reading his book.
</li>
<li>Andrzej Krzywda has a great <a href="http://andrzejonsoftware.blogspot.com/2011/02/dci-and-rails.html">intro post on DCI and Rails</a>.
</li>
<li>An <a href="http://www.artima.com/articles/dci_vision.html">article by the inventors of DCI</a> laying out the foundations of
    the pattern.
</li>
</ul>




</div>

</div>

<div id="outline-container-24" class="outline-2">
<h2 id="sec-24"><span class="section-number-2">24</span> Conclusion </h2>
<div class="outline-text-2" id="text-24">


<p>
  Well, that brings us to the end of our Object-Oriented Rails
  walkthrough. There's a lot more ground I could cover, but this is
  already about 80 pages longer than I intended it to be.
</p>
<p>
  I've tried to cram a number of ideas for how to build web
  applications using Object-Oriented methods and Test-Driven Design
  into this text. Some of them are techniques I use daily; some I use
  occasionally; and a few I came up with as I was writing this. My
  hope is that you're imagination has been sparked by one or two of
  these techniques, and you'll be inspired to try them out, or try
  variations, on your own projects. If you do, I hope you'll drop me a
  line and let me know how it went.
</p>

</div>

<div id="outline-container-24-1" class="outline-3">
<h3 id="sec-24-1"><span class="section-number-3">24.1</span> Feelin' the burn </h3>
<div class="outline-text-3" id="text-24-1">

<blockquote>

<p>Pain don't hurt
</p>
<p>
&mdash;Dalton, from "Roadhouse"
</p>
</blockquote>


<p>
A lot of the patterns we've looked at have been significantly more
work than following the traditional Rails development process. For
instance, we went to an awful lot of effort to avoid exposing common
ActiveRecord methods on the <code>Post</code> class.
</p>
<p>
Is all this extra effort worth it? Well, that depends on the
application. But in my experience a lot of Rails projects I've worked
on could have benefitted from a little initial pain. Many of these
pain points are really canaries in a coal mine, letting us know that
our code is becoming overly coupled, our interfaces too large, our
objects saddled with too many responsibilities. Like muscles which
have sat too long in one position, we don't realize how knotted-up
they've become until we stand up and stretch. Disciplines like
isolated tests, or <code>FigLeaf</code>, keep us on our toes and keep those
muscles from knotting up in the first place.
</p>
</div>

</div>

<div id="outline-container-24-2" class="outline-3">
<h3 id="sec-24-2"><span class="section-number-3">24.2</span> Wrap-up </h3>
<div class="outline-text-3" id="text-24-2">


<p>
I'm not sure mini-books like this are well-served by long
afterwards. (Or long introductions, for that matter; sorry about
that!). It's been a ton of work but a lot of fun writing this; I hope
you get some value from it. If you have questions, corrections,
suggestions, or objections, please don't hesitate to <a href="http://avdi.org">get in touch</a>. I'm
always interested in seeing how other developers tackle the problems
of sustainably growing and evolving a codebase.
</p>
<p>
Thanks for reading, and happy hacking!
</p>
</div>
</div>

</div>

<div id="outline-container-25" class="outline-2">
<h2 id="sec-25"><span class="section-number-2">25</span> Further reading </h2>
<div class="outline-text-2" id="text-25">


<p>
  There has been a surge of interest in applying classic Object
  Oriented principles to Rails development lately. Here are some
  starting points for further reading.
</p>
<ul>
<li>Steven Baker is writing an eBook on applying SOLID principles to
  Rails code, called <a href="http://solidrailsbook.com">Solid Rails</a>.
</li>
<li>As I mentioned earlier, Jim Gay has a forthcoming book on <a href="http://www.clean-ruby.com/">DCI in Ruby and Rails</a>.
</li>
<li>Steve Klabnick wrote an article called "<a href="http://blog.steveklabnik.com/2011/09/06/the-secret-to-rails-oo-design.html">The Secret to Rails OO Design</a>"

</li>
<li>In September 2011 The Ruby Rogues podcast (of which I am a member)
  interviewed Jim Weirich on the topic of "<a href="http://rubyrogues.com/object-oriented-programming-in-rails-with-jim-weirich/">Object Oriented Programming with Rails</a>".
</li>
<li>My fellow <a href="http://codebenders.com">CodeBender</a> Piotr Solnica has writte on the topic of
  "<a href="http://solnic.eu/2011/08/01/making-activerecord-models-thin.html">Making ActiveRecord Models Thin</a>", on separating business models
  from ActiveRecord classes.
</li>
<li>Gary Bernhardt has been offering up a wealth of information on clean
  OO design and writing fast, isolated tests in his <a href="https://www.destroyallsoftware.com/screencasts">Destroy All Software</a> video series.
</li>
<li>Greg Brown has been writing some great stuff on this topic; for
  instance, here's an article on applying <a href="http://blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html">SOLID Design Principles</a> to
  Ruby code based on his experience writing the Prawn PDF library.
</li>
<li>Nicholas Henry: "<a href="http://blog.firsthand.ca/2011/10/rails-is-not-your-application.html">Rails is Not Your Application</a>".
</li>
<li>Corey Haines has been giving talks on <a href="http://confreaks.net/videos/641-gogaruco2011-fast-rails-tests">fast rails tests</a>.
</li>
</ul>


</div>

</div>

<div id="outline-container-26" class="outline-2">
<h2 id="sec-26"><span class="section-number-2">26</span> Photo Credits </h2>
<div class="outline-text-2" id="text-26">

<ul>
<li>"Wet Paint" photo by <a href="http://www.flickr.com/photos/bixentro/2828929186/">"bixentro" on Flickr</a>. 
</li>
</ul>


</div>

</div>

<div id="outline-container-27" class="outline-2">
<h2 id="sec-27"><span class="section-number-2">27</span> Issues </h2>
<div class="outline-text-2" id="text-27">


</div>

<div id="outline-container-27-1" class="outline-3">
<h3 id="sec-27-1"><span class="section-number-3">27.1</span> <span class="todo TODO"> TODO</span> Either resolve or explain mixed "entries"/"posts" terminology </h3>
<div class="outline-text-3" id="text-27-1">

</div>

</div>

<div id="outline-container-27-2" class="outline-3">
<h3 id="sec-27-2"><span class="section-number-3">27.2</span> <span class="todo TODO"> TODO</span> Show all requires? </h3>
<div class="outline-text-3" id="text-27-2">

<p>   I've omitted many 'require' lines for brevity; perhaps I should
   either show them all or explain that I omit them.
</p></div>

</div>

<div id="outline-container-27-3" class="outline-3">
<h3 id="sec-27-3"><span class="section-number-3">27.3</span> <span class="todo TODO"> TODO</span> Show definition of <code>pubdate</code> accessors </h3>
<div class="outline-text-3" id="text-27-3">

</div>

</div>

<div id="outline-container-27-4" class="outline-3">
<h3 id="sec-27-4"><span class="section-number-3">27.4</span> <span class="todo TODO"> TODO</span> Reference Greg Moeck's work </h3>
<div class="outline-text-3" id="text-27-4">

<ul>
<li><a href="http://gmoeck.github.com/2011/10/26/stubbing-is-not-enough.html">http://gmoeck.github.com/2011/10/26/stubbing-is-not-enough.html</a>
</li>
<li><a href="http://confreaks.net/videos/659-rubyconf2011-why-you-don-t-get-mock-objects">http://confreaks.net/videos/659-rubyconf2011-why-you-don-t-get-mock-objects</a>
</li>
</ul>

</div>

</div>

<div id="outline-container-27-5" class="outline-3">
<h3 id="sec-27-5"><span class="section-number-3">27.5</span> <span class="todo TODO"> TODO</span> Consider Droid Sans for HTML version </h3>
<div class="outline-text-3" id="text-27-5">

<p>   From Martin Samson:
</p>
<blockquote>

<p>   Add the following line in the html code just before the style:
&lt;link href="<a href="http://fonts.googleapis.com/css?family=Droid">http://fonts.googleapis.com/css?family=Droid</a>
Sans&amp;subset=latin" rel="stylesheet" type="text/css"&gt;
</p>
<p>
Add 'Droid Sans' in the font-family of html:
 html { font-family: 'Droid Sans', Times, serif; font-size: 12pt; }
</p>
</blockquote>


</div>

</div>

<div id="outline-container-27-6" class="outline-3">
<h3 id="sec-27-6"><span class="section-number-3">27.6</span> <span class="todo TODO"> TODO</span> Talk a little about the project setup </h3>
<div class="outline-text-3" id="text-27-6">

<p>   Ruby/Rails/Gem versions
</p>
</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2011-11-16 01:13:53 EST</p>
<p class="author">Author: Avdi Grimm</p>
<p class="creator">Org version 7.7 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
